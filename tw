#!/bin/bash

# Teamwork.com CLI Tool
# Usage: tw <command>

set -e

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Cache directory
CACHE_DIR="/tmp/.tw_cache"
mkdir -p "$CACHE_DIR"

# Cache expiry time in seconds (30 minutes)
CACHE_EXPIRY=1800

# Function to get cache file path
get_cache_file() {
    local cache_key="$1"
    echo "$CACHE_DIR/${cache_key}.json"
}

# Function to check if cache is valid
is_cache_valid() {
    local cache_file="$1"
    local task_updated_at="$2"  # Optional - if provided, use task-based validation
    
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    # If task_updated_at is provided, use task-based validation (infinite cache unless task updated)
    if [ -n "$task_updated_at" ]; then
        # Check if cache metadata file exists
        local cache_meta_file="${cache_file}.meta"
        if [ ! -f "$cache_meta_file" ]; then
            return 1  # No metadata, cache invalid
        fi
        
        # Read cached task updatedAt timestamp
        local cached_updated_at=$(cat "$cache_meta_file" 2>/dev/null)
        
        # Compare timestamps - cache valid if task hasn't been updated since cache creation
        [ "$cached_updated_at" = "$task_updated_at" ]
    else
        # Fall back to time-based validation for non-task cache (projects, etc.)
        local cache_time=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)
        local current_time=$(date +%s)
        local age=$((current_time - cache_time))
        
        [ $age -lt $CACHE_EXPIRY ]
    fi
}

# Function to save to cache
save_to_cache() {
    local cache_key="$1"
    local data="$2"
    local task_updated_at="$3"  # Optional - if provided, save task metadata
    local cache_file=$(get_cache_file "$cache_key")
    
    echo "$data" > "$cache_file"
    
    # If task_updated_at is provided, save metadata for task-based cache validation
    if [ -n "$task_updated_at" ]; then
        local cache_meta_file="${cache_file}.meta"
        echo "$task_updated_at" > "$cache_meta_file"
    fi
}

# Function to load from cache
load_from_cache() {
    local cache_key="$1"
    local cache_file=$(get_cache_file "$cache_key")
    
    if is_cache_valid "$cache_file"; then
        cat "$cache_file"
        return 0
    else
        return 1
    fi
}

# Function to clear all cache
clear_cache() {
    rm -rf "$CACHE_DIR"
    mkdir -p "$CACHE_DIR"
    echo "Cache cleared successfully."
}

# Function to mark a task as actioned
mark_task_actioned() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        echo "Usage: tw action {task_id}"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    # First, fetch the current task to get its updatedAt timestamp
    local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
    local task_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id.json" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$task_response" ]; then
        echo "Error: Failed to fetch task $task_id from Teamwork API"
        return 1
    fi
    
    # Check if response contains error
    local error=$(echo "$task_response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "API Error: $error"
        return 1
    fi
    
    # Extract task details
    local task_name=$(echo "$task_response" | jq -r '.task.name // "Unknown Task"')
    local updated_at=$(echo "$task_response" | jq -r '.task.updatedAt // ""')
    
    if [ -z "$updated_at" ] || [ "$updated_at" = "null" ]; then
        echo "Error: Could not get task update timestamp"
        return 1
    fi
    
    # Save actioned status with timestamp
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    local actioned_data=$(jq -n --arg task_id "$task_id" --arg updated_at "$updated_at" --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '{
        taskId: $task_id,
        actionedAt: $timestamp,
        lastUpdatedAt: $updated_at
    }')
    
    echo "$actioned_data" > "$actioned_file"
    echo "Task $task_id marked as actioned: $task_name"
}

# Function to check if a task is marked as actioned and still valid
is_task_actioned() {
    local task_id="$1"
    local current_updated_at="$2"
    
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    
    if [ ! -f "$actioned_file" ]; then
        return 1  # Not actioned
    fi
    
    # Read the stored actioned data
    local stored_updated_at=$(cat "$actioned_file" | jq -r '.lastUpdatedAt // ""')
    
    # If current_updated_at is different from stored, the actioned status is invalid
    if [ "$current_updated_at" != "$stored_updated_at" ]; then
        # Remove the outdated actioned file
        rm "$actioned_file"
        return 1  # No longer valid
    fi
    
    return 0  # Still actioned and valid
}

# Function to remove actioned status for a task
unmark_task_actioned() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        echo "Usage: tw unaction {task_id}"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    
    if [ -f "$actioned_file" ]; then
        rm "$actioned_file"
        echo "Actioned status removed from task $task_id"
    else
        echo "Task $task_id was not marked as actioned"
    fi
}

# Function to check if a task was recently updated (within last 3 days)
is_recently_updated() {
    local updated_at="$1"
    
    if [ -z "$updated_at" ] || [ "$updated_at" = "null" ]; then
        return 1
    fi
    
    # Get current timestamp and 3 days ago timestamp
    local current_timestamp=$(date +%s)
    local three_days_ago=$((current_timestamp - 259200))  # 3 days = 3 * 24 * 60 * 60 seconds
    
    # Convert updatedAt to timestamp (handle different formats)
    local task_timestamp
    if [[ "$updated_at" =~ Z$ ]]; then
        task_timestamp=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$updated_at" +%s 2>/dev/null)
    elif [[ "$updated_at" =~ \+[0-9]{2}:[0-9]{2}$ ]]; then
        task_timestamp=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "${updated_at//:}" +%s 2>/dev/null)
    else
        task_timestamp=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$updated_at" +%s 2>/dev/null)
    fi
    
    if [ -z "$task_timestamp" ]; then
        return 1  # Could not parse timestamp
    fi
    
    # Check if task was updated within last 3 days
    [ "$task_timestamp" -gt "$three_days_ago" ]
}

# Function to clear cache for a specific task
clear_task_cache() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        echo "Usage: tw refresh {task_id}"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    local files_removed=0
    
    # Remove AI summary caches for this task (both short and long)
    for cache_file in "$CACHE_DIR"/ai_*_${task_id}_*.json; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed AI summary cache: $(basename "$cache_file")"
        fi
    done
    
    # Remove AI summary metadata files
    for cache_file in "$CACHE_DIR"/ai_*_${task_id}_*.json.meta; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed AI summary metadata: $(basename "$cache_file")"
        fi
    done
    
    # Remove task list caches (since they contain the task data that might be stale)
    # This ensures the task data is refreshed when viewing task lists
    for cache_file in "$CACHE_DIR"/tasks_*_*.json; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed task list cache: $(basename "$cache_file")"
        fi
    done
    
    # Remove task list metadata files
    for cache_file in "$CACHE_DIR"/tasks_*_*.json.meta; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed task list metadata: $(basename "$cache_file")"
        fi
    done
    
    # Remove actioned status file for this specific task
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    if [ -f "$actioned_file" ]; then
        rm "$actioned_file"
        files_removed=$((files_removed + 1))
        echo "Removed actioned status: $(basename "$actioned_file")"
    fi
    
    if [ $files_removed -eq 0 ]; then
        echo "No cache files found for task ID: $task_id"
    else
        echo "Cache cleared for task $task_id ($files_removed files removed)."
    fi
}

# Function to check if cached task data is still current by comparing updatedAt timestamps
is_task_data_current() {
    local cache_file="$1"
    local project_id="$2"
    
    # If cache doesn't exist, it's not current
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    # Get the most recent updatedAt from cached tasks
    local cached_updated=$(cat "$cache_file" | jq -r '.tasks | map(.updatedAt) | max')
    if [ "$cached_updated" = "null" ] || [ -z "$cached_updated" ]; then
        return 1
    fi
    
    # Fetch just basic task info to check updatedAt timestamps
    local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
    local current_response
    
    if [ "$project_id" = "ALL" ]; then
        current_response=$(curl -s -H "$auth_header" \
            "$TEAMWORK_URL/projects/api/v3/tasks.json?assigneeUserIds=$USER_ID&pageSize=500&fields=id,updatedAt" 2>/dev/null)
    else
        current_response=$(curl -s -H "$auth_header" \
            "$TEAMWORK_URL/projects/api/v3/projects/$project_id/tasks.json?fields=id,updatedAt" 2>/dev/null)
    fi
    
    # Check if API call failed
    if [ $? -ne 0 ] || [ -z "$current_response" ]; then
        # If API call fails, assume cache is still valid to avoid breaking functionality
        return 0
    fi
    
    # Get the most recent updatedAt from current data
    local current_updated=$(echo "$current_response" | jq -r '.tasks | map(.updatedAt) | max' 2>/dev/null)
    if [ "$current_updated" = "null" ] || [ -z "$current_updated" ]; then
        # If we can't get current timestamp, assume cache is valid
        return 0
    fi
    
    # Compare timestamps - return 0 if they match (current), 1 if different (not current)
    if [ "$cached_updated" = "$current_updated" ]; then
        return 0  # Data is current
    else
        return 1  # Data is not current
    fi
}

# Function to show first-time welcome message
show_welcome_message() {
    local welcome_flag_file="$CACHE_DIR/.tw_welcome_shown"
    
    # Check if welcome message has already been shown
    if [ -f "$welcome_flag_file" ]; then
        return 0  # Already shown, skip
    fi
    
    # Display welcome message in green box
    echo -e "\033[32m"  # Set green color
    cat << 'EOF'
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                                                                 │
│                          🎉 Welcome to Teamwork CLI! 🎉                        │
│                                                                                 │
│   Thank you for using the Teamwork.com command-line interface. This tool       │
│   helps you manage your tasks, projects, and workflow directly from your       │
│   terminal with powerful features like AI summaries and smart filtering.       │
│                                                                                 │
│   Created by: Anthony Keal                                                      │
│   Email: contact@business.anthonykeal.com.au                                    │
│                                                                                 │
│   💝 If you find this tool helpful, consider supporting development:           │
│   Buy Me a Coffee: https://buymeacoffee.com/anthonykeal                        │
│                                                                                 │
│   Get started by running 'tw flags' to see all available commands!             │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
EOF
    echo -e "\033[0m"  # Reset color
    echo
    
    # Create flag file to mark welcome message as shown
    touch "$welcome_flag_file"
    
    # Pause briefly to let user read the message
    echo "Press any key to continue..."
    read -n 1 -s
    echo
}

# Function to check if Claude CLI is available
check_claude_available() {
    if ! command -v claude &> /dev/null; then
        return 1
    fi
    return 0
}

# Function to show progress bar
show_progress_bar() {
    local current="$1"
    local total="$2"
    local width=20
    local percentage=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="█"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done
    
    echo -ne "\rGenerating AI summary $current of $total [$bar] ${percentage}% complete..." >&2
}

# Function to fetch task with latest 5 comments for AI context
get_task_with_comments() {
    local task_id="$1"
    local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
    
    # Fetch task details - clean control characters that break JSON parsing
    local task_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id.json" 2>/dev/null | sed 's/\\r//g; s/\\n/ /g')
    if [ $? -ne 0 ] || [ -z "$task_response" ]; then
        echo ""
        return 1
    fi
    
    # Fetch latest 5 comments in descending order (most recent first) - clean control characters
    local comments_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/comments.json?pageSize=5&orderMode=desc" 2>/dev/null | sed 's/\\r//g; s/\\n/ /g')
    
    # Combine task and comments data
    local combined_data=$(jq -n \
        --argjson task "$task_response" \
        --argjson comments "$comments_response" \
        '{task: $task.task, comments: $comments.comments}')
    
    echo "$combined_data"
}

# Function to generate short AI summary (1-2 sentences)
generate_short_summary() {
    local task_data="$1"
    local task_id="$2"
    local last_updated="$3"
    local debug_mode="${4:-false}"
    
    if ! check_claude_available; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Check cache first
    local cache_key="ai_short_${task_id}_${last_updated}"
    local cache_file=$(get_cache_file "$cache_key")
    
    if [ -f "$cache_file" ]; then
        cat "$cache_file"
        return 0
    fi
    
    # Extract task and comment information for AI
    local task_name=$(echo "$task_data" | jq -r '.task.name // "Unknown Task"')
    local task_description=$(echo "$task_data" | jq -r '.task.description // ""')
    local comments=$(echo "$task_data" | jq -r '.comments[]? | "- " + (.body // "")' | head -5)
    local comment_count=$(echo "$task_data" | jq '.comments | length')
    
    # Check if task is empty (no description and no comments)
    if [ -z "$task_description" ] || [ "$task_description" = "null" ] || [ "$task_description" = "" ]; then
        if [ "$comment_count" -eq 0 ] || [ -z "$comments" ]; then
            local empty_summary="Empty task"
            echo "$empty_summary" > "$cache_file"
            echo "$empty_summary"
            return 0
        fi
    fi
    
    # Debug output if requested
    if [ "$debug_mode" = "true" ]; then
        echo "=== DEBUG: Task Data Structure ===" >&2
        echo "Task Name: $task_name" >&2
        echo "Task Description: $task_description" >&2
        echo "Comments Count: $(echo "$task_data" | jq '.comments | length')" >&2
        echo "Comments:" >&2
        echo "$comments" >&2
        echo "=== END DEBUG ===" >&2
    fi
    
    # Build AI prompt with clear context labels
    local prompt="You are analyzing a Teamwork task assigned to you. Carefully read the task title, description, and recent comments to understand the current status and what you need to know.

TASK TITLE: $task_name

TASK DESCRIPTION: $task_description

RECENT COMMENTS (most recent first):
$comments

Based on the task title, description, and comments above, provide a concise 1-2 sentence summary that tells you:
1. What is the current status of this task?
2. What should you focus on or do next?

Focus on actionable information that helps you understand where things stand and what your next steps should be."
    
    # Generate AI summary
    local ai_response=$(echo "$prompt" | claude 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$ai_response" ]; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Clean up response and cache it
    local clean_response=$(echo "$ai_response" | sed 's/^[ \t]*//;s/[ \t]*$//' | head -3 | tr '\n' ' ' | sed 's/  */ /g')
    echo "$clean_response" > "$cache_file"
    echo "$clean_response"
}

# Function to generate long AI summary with sections
generate_long_summary() {
    local task_data="$1"
    local task_id="$2"
    local last_updated="$3"
    local debug_mode="${4:-false}"
    
    if ! check_claude_available; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Check cache first
    local cache_key="ai_long_${task_id}_${last_updated}"
    local cache_file=$(get_cache_file "$cache_key")
    
    if [ -f "$cache_file" ]; then
        cat "$cache_file"
        return 0
    fi
    
    # Extract task and comment information for AI
    local task_name=$(echo "$task_data" | jq -r '.task.name // "Unknown Task"')
    local task_description=$(echo "$task_data" | jq -r '.task.description // ""')
    local priority=$(echo "$task_data" | jq -r '.task.priority // "Normal"')
    local due_date=$(echo "$task_data" | jq -r '.task.dueDate // "Not set"')
    local comments=$(echo "$task_data" | jq -r '.comments[]? | "- " + (.body // "")' | head -5)
    local comment_count=$(echo "$task_data" | jq '.comments | length')
    
    # Check if task is empty (no description and no comments)
    if [ -z "$task_description" ] || [ "$task_description" = "null" ] || [ "$task_description" = "" ]; then
        if [ "$comment_count" -eq 0 ] || [ -z "$comments" ]; then
            local empty_summary="Empty task - no description or comments available"
            echo "$empty_summary" > "$cache_file"
            echo "$empty_summary"
            return 0
        fi
    fi
    
    # Debug output if requested
    if [ "$debug_mode" = "true" ]; then
        echo "=== DEBUG: Long Summary Data ===" >&2
        echo "Task Name: $task_name" >&2
        echo "Task Description: $task_description" >&2
        echo "Priority: $priority" >&2
        echo "Due Date: $due_date" >&2
        echo "Comments Count: $(echo "$task_data" | jq '.comments | length')" >&2
        echo "Comments:" >&2
        echo "$comments" >&2
        echo "=== END DEBUG ===" >&2
    fi
    
    # Build AI prompt with comprehensive context
    local prompt="You are analyzing a Teamwork task assigned to you. Carefully examine the task title, description, and recent comments to provide a comprehensive analysis of the current situation and what you need to do.

TASK TITLE: $task_name

PRIORITY: $priority

DUE DATE: $due_date

TASK DESCRIPTION: $task_description

RECENT COMMENTS (most recent first):
$comments

Analyze the task title, description, and comments above to understand:
- What work has been done so far?
- What is the current status/progress?
- What blockers or issues exist?
- What should you do next?

Format your response exactly as:

SUMMARY: [2-3 sentences about the current status and progress based on analyzing the title, description, and comments. Focus on what you need to know about where things stand.]

NEXT STEPS:
- [specific action you should take based on the task context]
- [another actionable step if applicable]
- [additional steps as needed to move forward]

Prioritize actionable insights that help you understand your current responsibilities and next actions for this specific task."
    
    # Generate AI summary
    local ai_response=$(echo "$prompt" | claude 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$ai_response" ]; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Cache and return response
    echo "$ai_response" > "$cache_file"
    echo "$ai_response"
}

# Load environment variables from .env file in script directory or user's home
if [ -f "$SCRIPT_DIR/.env" ]; then
    export $(grep -v '^#' "$SCRIPT_DIR/.env" | xargs)
elif [ -f "$HOME/.tw.env" ]; then
    export $(grep -v '^#' "$HOME/.tw.env" | xargs)
else
    echo "Error: .env file not found."
    echo "Create either:"
    echo "  - $SCRIPT_DIR/.env (local to script)"
    echo "  - $HOME/.tw.env (global config)"
    echo ""
    echo "Use $SCRIPT_DIR/.env.example as template"
    exit 1
fi

# Check required environment variables
if [ -z "$TEAMWORK_URL" ] || [ -z "$API_KEY" ] || [ -z "$PASSWORD" ] || [ -z "$USER_ID" ]; then
    echo "Error: Missing required environment variables. Check your .env file."
    exit 1
fi

# Show welcome message on first run
show_welcome_message

# Function to fetch all projects user is assigned to
fetch_assigned_projects() {
    local cache_key="projects_${USER_ID}"
    
    # Try to load from cache first
    local cache_file=$(get_cache_file "$cache_key")
    if is_cache_valid "$cache_file"; then
        echo "Loading projects from cache..." >&2
        cat "$cache_file"
        return 0
    fi
    
    local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
    
    echo "Finding projects you are assigned to..." >&2
    
    # Fetch projects where user is assigned using the projects endpoint
    local response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/projects.json?userId=$USER_ID&pageSize=200")
    
    if [ $? -ne 0 ]; then
        echo "Error: Failed to fetch projects from Teamwork API" >&2
        exit 1
    fi
    
    # Check if response contains error
    local error=$(echo "$response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "API Error: $error" >&2
        exit 1
    fi
    
    # Extract projects and format them, add ALL PROJECTS option
    local formatted_projects=$(echo "$response" | jq '
        [.projects[] | {id: .id, name: .name}] + [{"id": "ALL", "name": "ALL PROJECTS"}]
    ')
    
    # Save to cache
    save_to_cache "$cache_key" "$formatted_projects"
    
    echo "$formatted_projects"
}

# Function for project selection wizard with arrow key navigation
project_wizard() {
    
    local projects_json=$(fetch_assigned_projects)
    
    # Debug: check what we got
    if [ -z "$projects_json" ]; then
        echo "Error: No projects data received"
        exit 1
    fi
    
    local project_count=$(echo "$projects_json" | jq 'length' 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$project_count" ]; then
        echo "Error: Invalid JSON data received"
        echo "Debug data: $projects_json"
        exit 1
    fi
    
    if [ "$project_count" -eq 0 ]; then
        echo "No projects found."
        exit 1
    fi
    
    local selected=0
    local key
    
    # Function to display projects list
    display_projects() {
        clear
        echo "Select a project:"
        echo "Use up/down arrow keys to navigate, Enter to select, q to quit"
        echo
        
        printf "┌─────────────────────────────────────────────────────────────────────────────────┐\n"
        printf "│ %-79s │\n" "Available Projects"
        printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
        
        for i in $(seq 0 $((project_count - 1))); do
            local project_id=$(echo "$projects_json" | jq -r ".[$i].id")
            local project_name=$(echo "$projects_json" | jq -r ".[$i].name")
            
            if [ $i -eq $selected ]; then
                if [ "$project_id" = "ALL" ]; then
                    printf "│ > %-76s │\n" "$(echo "$project_name" | cut -c1-76)"
                else
                    printf "│ > ID:%-7s %-66s │\n" "$project_id" "$(echo "$project_name" | cut -c1-66)"
                fi
            else
                if [ "$project_id" = "ALL" ]; then
                    printf "│   %-76s │\n" "$(echo "$project_name" | cut -c1-76)"
                else
                    printf "│   ID:%-7s %-66s │\n" "$project_id" "$(echo "$project_name" | cut -c1-66)"
                fi
            fi
        done
        
        printf "└─────────────────────────────────────────────────────────────────────────────────┘\n"
    }
    
    display_projects
    
    while true; do
        read -rsn1 key
        case "$key" in
            $'\x1b')  # ESC sequence
                read -rsn2 key
                case "$key" in
                    '[A')  # Up arrow
                        selected=$((selected - 1))
                        if [ $selected -lt 0 ]; then
                            selected=$((project_count - 1))
                        fi
                        display_projects
                        ;;
                    '[B')  # Down arrow
                        selected=$((selected + 1))
                        if [ $selected -ge $project_count ]; then
                            selected=0
                        fi
                        display_projects
                        ;;
                esac
                ;;
            '')  # Enter key
                local selected_project_id=$(echo "$projects_json" | jq -r ".[$selected].id")
                echo
                echo "Selected project: $(echo "$projects_json" | jq -r ".[$selected].name")"
                
                # Store selected project in a temp file for future use
                echo "$selected_project_id" > /tmp/.tw_selected_project
                exit 0
                ;;
            'q'|'Q')
                echo
                echo "Cancelled."
                exit 0
                ;;
        esac
    done
}

# Function to select project if multiple exist
select_project() {
    # Check if there's a stored project selection
    if [ -f "/tmp/.tw_selected_project" ]; then
        local stored_project=$(cat /tmp/.tw_selected_project)
        if [ -n "$stored_project" ]; then
            echo "$stored_project"
            return
        fi
    fi
    
    # If no stored project, return empty and let calling function handle it
    echo ""
    return 1
}

# Function to format date from ISO to DD-MM-YYYY
format_date() {
    local iso_date="$1"
    if [ -n "$iso_date" ] && [ "$iso_date" != "null" ]; then
        date -j -f "%Y-%m-%dT%H:%M:%SZ" "$iso_date" "+%d-%m-%Y" 2>/dev/null || echo "No due date"
    else
        echo "No due date"
    fi
}

# Function to format markdown bold text for terminal
format_markdown() {
    local text="$1"
    # Convert **text** to bold using ANSI escape codes
    echo "$text" | sed 's/\*\*\([^*]*\)\*\*/\x1b[1m\1\x1b[0m/g'
}

# Function to format text with colors and bold  
format_priority() {
    local priority="$1"
    case "$priority" in
        "HIGH") 
            # Red color AND bold for HIGH priority - use printf for better compatibility
            printf '\033[31m\033[1m*** Priority: HIGH ***\033[0m'
            ;;
        *) echo "Priority: $priority" ;;
    esac
}

# Function to format dates (check if overdue)
format_due_date() {
    local due_date="$1"
    local formatted_date="$2"
    
    if [ -n "$due_date" ] && [ "$due_date" != "null" ] && [ "$due_date" != "No due date" ]; then
        local today=$(date "+%Y-%m-%d")
        local due_date_only=$(echo "$due_date" | sed 's/T.*//')
        
        if [ "$due_date_only" \< "$today" ]; then
            # Overdue - red color
            printf '\033[31m!!! Due: %s !!!\033[0m' "$formatted_date"
        else
            echo "Due: $formatted_date"
        fi
    else
        echo "Due: $formatted_date"
    fi
}

# Function to format task titles in bold with status indicators
format_task_title() {
    local title="$1"
    local task_id="$2"
    local updated_at="$3"
    
    # Build status indicators
    local status_indicators=""
    if [ -n "$task_id" ] && [ -n "$updated_at" ]; then
        if is_task_actioned "$task_id" "$updated_at"; then
            status_indicators="$(format_actioned_status)"
        fi
        if is_recently_updated "$updated_at"; then
            if [ -n "$status_indicators" ]; then
                status_indicators="$status_indicators $(format_recently_updated_status)"
            else
                status_indicators="$(format_recently_updated_status)"
            fi
        fi
    fi
    
    # Format title with status indicators
    if [ -n "$status_indicators" ]; then
        printf '\033[1m>> %s <<\033[0m %s' "$title" "$status_indicators"
    else
        printf '\033[1m>> %s <<\033[0m' "$title"
    fi
}

# Function to format actioned status in green and bold
format_actioned_status() {
    printf '\033[32m\033[1m[ACTIONED]\033[0m'
}

# Function to format recently updated status in yellow and bold
format_recently_updated_status() {
    printf '\033[33m\033[1m[RECENTLY UPDATED]\033[0m'
}

# Function to strip ANSI color codes for width calculation
strip_colors() {
    # Strip various escape sequence formats
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\[[0-9;]*m//g' | sed 's/(B\[m//g'
}

# Function to pad colored text to specific width
pad_colored_text() {
    local text="$1"
    local width="$2"
    local stripped=$(strip_colors "$text")
    local padding=$((width - ${#stripped}))
    
    if [ $padding -gt 0 ]; then
        printf "%s%*s" "$text" $padding ""
    else
        echo "$text"
    fi
}

# Function to wrap text for table display (79 characters per line)
wrap_text_for_table() {
    local text="$1"
    local remaining_text="$text"
    
    while [ ${#remaining_text} -gt 79 ]; do
        local chunk="${remaining_text:0:79}"
        
        # Try to break at word boundary by finding the last space within the chunk
        local break_pos=79
        
        # Look for the last space character within reasonable distance from the end
        for ((pos=79; pos>=60; pos--)); do
            if [ "${remaining_text:$((pos-1)):1}" = " " ]; then
                break_pos=$pos
                break
            fi
        done
        
        # Extract the chunk and update remaining content
        chunk="${remaining_text:0:$break_pos}"
        
        # Skip the space if we broke at a word boundary
        if [ "${remaining_text:$((break_pos-1)):1}" = " " ]; then
            remaining_text="${remaining_text:$break_pos}"
        else
            remaining_text="${remaining_text:$break_pos}"
        fi
        
        # Trim trailing spaces from chunk
        chunk="${chunk%"${chunk##*[![:space:]]}"}"
        printf "│ %-79s │\n" "$chunk"
    done
    
    # Display remaining text
    if [ -n "$remaining_text" ]; then
        printf "│ %-79s │\n" "$remaining_text"
    fi
}

# Function to format long summary with proper section separation
format_long_summary() {
    local ai_summary="$1"
    local has_tags="$2"
    
    # Add separator before summary if there are tags displayed
    if [ "$has_tags" = "true" ]; then
        printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
    fi
    
    # Process the AI summary line by line with section formatting
    local in_next_steps=false
    local first_line=true
    
    echo "$ai_summary" | while IFS= read -r line; do
        # Check if this line starts a new section
        if [[ "$line" =~ ^(SUMMARY|NEXT STEPS): ]]; then
            # Add separator before new sections (except the very first one)
            if [ "$first_line" != "true" ]; then
                printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
            fi
            first_line=false
            
            # Check if we're entering the NEXT STEPS section
            if [[ "$line" =~ ^NEXT\ STEPS: ]]; then
                in_next_steps=true
            else
                in_next_steps=false
            fi
        fi
        
        # Format the line content
        if [ -n "$line" ]; then
            wrap_text_for_table "$line"
        else
            # Empty lines become separator lines
            printf "│ %-79s │\n" ""
        fi
    done
}

# Function to fetch tags for the project and create a lookup map
fetch_tags() {
    local project_id="$1"
    local cache_key="tags_global"
    
    # Try to load from cache first
    local cache_file=$(get_cache_file "$cache_key")
    if is_cache_valid "$cache_file"; then
        echo "Loading tags from cache..." >&2
        cat "$cache_file"
        return 0
    fi
    
    local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
    
    # Fetch tags - the API seems to be global but we can filter if needed
    local response=$(curl -s -H "$auth_header" \
        "$TEAMWORK_URL/projects/api/v3/tags.json?pageSize=500")
    
    if [ $? -ne 0 ]; then
        echo "{}" # Return empty object on error
        return 1
    fi
    
    # Check if response contains error
    local error=$(echo "$response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "{}" # Return empty object on error
        return 1
    fi
    
    # Convert tags array to lookup object {tagId: {name: "tag name", color: "color"}}
    local tags_lookup=$(echo "$response" | jq -r '
        .tags | map({(.id | tostring): {name: .name, color: .color}}) | add // {}
    ')
    
    # Save to cache
    save_to_cache "$cache_key" "$tags_lookup"
    
    echo "$tags_lookup"
}

# Function to format tags for display
format_tags() {
    local tag_ids="$1"
    local tags_lookup="$2"
    
    if [ -z "$tag_ids" ] || [ "$tag_ids" = "null" ] || [ "$tag_ids" = "[]" ]; then
        echo ""
        return
    fi
    
    # Parse tag IDs and format them
    local tag_names=$(echo "$tag_ids" | jq -r --argjson lookup "$tags_lookup" '
        if type == "array" then
            map(tostring) | map($lookup[.].name // ("Tag " + .)) | join(", ")
        else
            empty
        end
    ' 2>/dev/null)
    
    if [ -n "$tag_names" ] && [ "$tag_names" != "null" ]; then
        echo "$tag_names"
    else
        echo ""
    fi
}

# Function to check if a task matches priority filter
matches_priority_filter() {
    local task_priority="$1"
    local filter="$2"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    # Convert to lowercase for case-insensitive comparison
    local task_priority_lower=$(echo "$task_priority" | tr '[:upper:]' '[:lower:]')
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    
    case "$filter_lower" in
        "high") [ "$task_priority_lower" = "high" ] ;;
        "medium") [ "$task_priority_lower" = "medium" ] ;;
        "low") [ "$task_priority_lower" = "low" ] ;;
        "normal") [ "$task_priority_lower" = "normal" ] || [ -z "$task_priority" ] ;;
        *) return 1 ;;
    esac
}

# Function to check if a task matches due date filter
matches_due_filter() {
    local task_due_date="$1"
    local filter="$2"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    local today=$(date "+%Y-%m-%d")
    
    case "$filter_lower" in
        "today")
            [ "$(echo "$task_due_date" | sed 's/T.*//')" = "$today" ]
            ;;
        "overdue")
            if [ -n "$task_due_date" ] && [ "$task_due_date" != "null" ]; then
                local due_date_only=$(echo "$task_due_date" | sed 's/T.*//')
                [ "$due_date_only" \< "$today" ]
            else
                return 1
            fi
            ;;
        */*/* | *-*-*)
            # Date format - try to parse various formats
            local input_date=""
            if [[ "$filter" =~ ^[0-9]{1,2}/[0-9]{1,2}/[0-9]{2,4}$ ]]; then
                # DD/MM/YY or DD/MM/YYYY format
                input_date=$(echo "$filter" | awk -F'/' '{
                    year = $3
                    if (length(year) == 2) year = "20" year
                    printf "%04d-%02d-%02d", year, $2, $1
                }')
            elif [[ "$filter" =~ ^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$ ]]; then
                # YYYY-MM-DD format
                input_date="$filter"
            else
                return 1
            fi
            
            if [ -n "$task_due_date" ] && [ "$task_due_date" != "null" ]; then
                local due_date_only=$(echo "$task_due_date" | sed 's/T.*//')
                [ "$due_date_only" = "$input_date" ]
            else
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to check if a task matches start date filter
matches_start_filter() {
    local task_start_date="$1"
    local filter="$2"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    local today=$(date "+%Y-%m-%d")
    
    case "$filter_lower" in
        "today")
            [ "$(echo "$task_start_date" | sed 's/T.*//')" = "$today" ]
            ;;
        */*/* | *-*-*)
            # Date format - same logic as due date
            local input_date=""
            if [[ "$filter" =~ ^[0-9]{1,2}/[0-9]{1,2}/[0-9]{2,4}$ ]]; then
                input_date=$(echo "$filter" | awk -F'/' '{
                    year = $3
                    if (length(year) == 2) year = "20" year
                    printf "%04d-%02d-%02d", year, $2, $1
                }')
            elif [[ "$filter" =~ ^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$ ]]; then
                input_date="$filter"
            else
                return 1
            fi
            
            if [ -n "$task_start_date" ] && [ "$task_start_date" != "null" ]; then
                local start_date_only=$(echo "$task_start_date" | sed 's/T.*//')
                [ "$start_date_only" = "$input_date" ]
            else
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to check if a task matches tags filter
matches_tags_filter() {
    local task_tag_ids="$1"
    local tags_lookup="$2"
    local filter="$3"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    if [ -z "$task_tag_ids" ] || [ "$task_tag_ids" = "null" ] || [ "$task_tag_ids" = "[]" ]; then
        return 1  # Task has no tags
    fi
    
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    
    # Get tag names for this task
    local task_tag_names=$(echo "$task_tag_ids" | jq -r --argjson lookup "$tags_lookup" '
        if type == "array" then
            map(tostring) | map($lookup[.].name // "") | join("|")
        else
            ""
        end
    ' 2>/dev/null)
    
    if [ -n "$task_tag_names" ]; then
        local task_tag_names_lower=$(echo "$task_tag_names" | tr '[:upper:]' '[:lower:]')
        echo "$task_tag_names_lower" | grep -q "$filter_lower"
    else
        return 1
    fi
}

# Function to get tasks
get_tasks() {
    # Filter parameters
    local priority_filter=""
    local due_filter=""
    local start_filter=""
    local tags_filter=""
    local summary_mode=""
    local debug_mode="false"
    local order_by="duedate"  # Default ordering
    local clear_terminal="true"  # Default to clearing terminal
    
    # Parse flags
    shift # Remove 'tasks' from arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --priority=*)
                priority_filter="${1#*=}"
                shift
                ;;
            --due=*)
                due_filter="${1#*=}"
                shift
                ;;
            --start=*)
                start_filter="${1#*=}"
                shift
                ;;
            --tags=*)
                tags_filter="${1#*=}"
                shift
                ;;
            --summary=*)
                summary_mode="${1#*=}"
                shift
                ;;
            --summary)
                summary_mode="short"
                shift
                ;;
            --order=*)
                order_by="${1#*=}"
                shift
                ;;
            --debug)
                debug_mode="true"
                shift
                ;;
            --no-clear)
                clear_terminal="false"
                shift
                ;;
            --help)
                echo "Use 'tw flags' to see available commands and options."
                return 0
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use 'tw tasks --help' for usage information."
                return 1
                ;;
        esac
    done
    
    local project_id=$(select_project)
    if [ $? -ne 0 ] || [ -z "$project_id" ]; then
        echo "No project selected. Please run 'tw' to select a project first."
        exit 1
    fi
    
    # Try to load from cache first
    local cache_key="tasks_${project_id}_${USER_ID}"
    local cache_file=$(get_cache_file "$cache_key")
    local show_update_indicator=false
    
    if ! is_cache_valid "$cache_file"; then
        # Cache miss - fetch from API
        local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
        
        if [ "$project_id" = "ALL" ]; then
            echo "Fetching tasks from all projects..."
            echo
            
            # Fetch tasks from all projects using the tasks endpoint with user filter
            response=$(curl -s -H "$auth_header" \
                "$TEAMWORK_URL/projects/api/v3/tasks.json?assigneeUserIds=$USER_ID&pageSize=500")
        else
            echo "Fetching tasks for project $project_id..."
            echo
            
            # Fetch tasks from specific project
            response=$(curl -s -H "$auth_header" \
                "$TEAMWORK_URL/projects/api/v3/projects/$project_id/tasks.json")
        fi
        
        if [ $? -ne 0 ]; then
            echo "Error: Failed to fetch tasks from Teamwork API"
            exit 1
        fi
        
        # Check if response contains error
        local error=$(echo "$response" | jq -r '.error // empty')
        if [ -n "$error" ]; then
            echo "API Error: $error"
            exit 1
        fi
        
        # Save to cache
        save_to_cache "$cache_key" "$response"
    else
        # Cache exists - check if task data is still current
        if is_task_data_current "$cache_file" "$project_id"; then
            echo "Loading tasks from cache..."
            echo
            show_update_indicator=true
        else
            echo "Tasks have been updated - fetching fresh data..."
            echo
            # Fetch fresh data since tasks were updated
            local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
            
            if [ "$project_id" = "ALL" ]; then
                # Fetch tasks from all projects
                response=$(curl -s -H "$auth_header" \
                    "$TEAMWORK_URL/projects/api/v3/tasks.json?assigneeUserIds=$USER_ID&pageSize=500")
            else
                # Fetch tasks from specific project
                response=$(curl -s -H "$auth_header" \
                    "$TEAMWORK_URL/projects/api/v3/projects/$project_id/tasks.json")
            fi
            
            if [ $? -ne 0 ]; then
                echo "Error: Failed to fetch tasks from Teamwork API"
                exit 1
            fi
            
            # Check if response contains error
            local error=$(echo "$response" | jq -r '.error // empty')
            if [ -n "$error" ]; then
                echo "API Error: $error"
                exit 1
            fi
            
            # Save fresh data to cache
            save_to_cache "$cache_key" "$response"
        fi
        local response=$(cat "$cache_file")
    fi
    
    # Fetch tags if needed (for display or filtering)
    local tags_lookup="{}"
    if [ -n "$tags_filter" ]; then
        tags_lookup=$(fetch_tags "$project_id")
    fi
    
    # Store tasks data for processing with dynamic sorting
    local sort_expression=""
    local order_description=""
    
    case "$order_by" in
        "priority")
            # Sort by priority: high=1, medium=2, normal/null=3, low=4
            sort_expression='sort_by(if .priority == "high" then 1 elif .priority == "medium" then 2 elif (.priority == "low") then 4 else 3 end)'
            order_description="priority order (high → medium → normal → low)"
            ;;
        "lastupdated"|"updated")
            sort_expression='sort_by(.updatedAt // "1900-01-01") | reverse'
            order_description="last updated (newest first)"
            ;;
        "duedate"|"due")
            sort_expression='sort_by(.dueDate // "9999-12-31")'
            order_description="due date order (overdue first)"
            ;;
        "start"|"startdate")
            sort_expression='sort_by(.startDate // "9999-12-31")'
            order_description="start date order"
            ;;
        *)
            # Default to due date
            sort_expression='sort_by(.dueDate // "9999-12-31")'
            order_description="due date order (overdue first)"
            ;;
    esac
    
    local tasks_data=$(echo "$response" | jq -r --arg user_id "$USER_ID" '
        .tasks[]
        | select(.assigneeUserIds[]? == ($user_id | tonumber))
        | select(.status != "completed" and .status != "complete" and .status != "done" and .progress != 100)
        | {
            id: .id,
            name: .name,
            priority: .priority,
            dueDate: .dueDate,
            startDate: .startDate,
            description: .description,
            projectId: .projectId,
            tagIds: .tagIds,
            updatedAt: .updatedAt
        }
    ' | jq -s "$sort_expression")
    
    # Count total tasks found
    local task_count=$(echo "$tasks_data" | jq 'length')
    
    # Clear terminal if enabled (default behavior)
    if [ "$clear_terminal" = "true" ]; then
        # Full terminal reset: clear screen, scrollback buffer, and reset cursor
        printf '\033[2J\033[3J\033[H'
    fi
    
    # Display task summary
    echo "Found $task_count task(s) assigned to you."
    echo "Tasks displayed in $order_description."
    echo
    
    # Format and display tasks
    local total_tasks=$(echo "$tasks_data" | jq 'length')
    local task_counter=0
    
    # Process tasks with progress tracking
    while IFS= read -r task; do
        task_counter=$((task_counter + 1))
        local task_id=$(echo "$task" | jq -r '.id')
        local task_name=$(echo "$task" | jq -r '.name')
        local due_date=$(echo "$task" | jq -r '.dueDate // "No due date"')
        local start_date=$(echo "$task" | jq -r '.startDate // "No start date"')
        local priority=$(echo "$task" | jq -r '.priority // "Normal"')
        local description=$(echo "$task" | jq -r '.description // ""')
        local tag_ids=$(echo "$task" | jq -r '.tagIds // "[]"')
        local updated_at=$(echo "$task" | jq -r '.updatedAt // ""')
        local formatted_due=$(echo "$due_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$due_date")
        local formatted_start=$(echo "$start_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$start_date")
        
        # Apply filters - skip task if it doesn't match
        if ! matches_priority_filter "$priority" "$priority_filter"; then
            continue
        fi
        
        if ! matches_due_filter "$due_date" "$due_filter"; then
            continue
        fi
        
        if ! matches_start_filter "$start_date" "$start_filter"; then
            continue
        fi
        
        if ! matches_tags_filter "$tag_ids" "$tags_lookup" "$tags_filter"; then
            continue
        fi
        
        # Format tags if needed
        local formatted_tags=""
        if [ -n "$tags_filter" ]; then
            formatted_tags=$(format_tags "$tag_ids" "$tags_lookup")
        fi
        
        # Priority display with emoji
        local priority_display="$priority"
        case "$priority" in
            "high") priority_display="HIGH" ;;
            "medium") priority_display="MEDIUM" ;;
            "low") priority_display="LOW" ;;
            *) priority_display="NORMAL" ;;
        esac
        
        # Format priority with color
        local formatted_priority=$(format_priority "$priority_display")
        
        # Format due date with overdue check
        local formatted_due_with_color=$(format_due_date "$due_date" "$formatted_due")
        
        # Format task title in bold with status indicators
        local formatted_title=$(format_task_title "$task_name" "$task_id" "$updated_at")
        
        # Build task URL
        local task_url="$TEAMWORK_URL/app/tasks/$task_id"
        
        # Display task in table format
        printf "┌─────────────────────────────────────────────────────────────────────────────────┐\n"
        echo "│ $(pad_colored_text "$formatted_title" 79) │"
        printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
        # Format with proper padding for colored text
        local id_part="ID: $task_id"
        local priority_padded=$(pad_colored_text "$formatted_priority" 20)
        local due_padded=$(pad_colored_text "$formatted_due_with_color" 36)
        echo "│ $(printf "%-15s" "$id_part") │ $priority_padded │ $due_padded │"
        
        # Show description if it exists
        if [ -n "$description" ] && [ "$description" != "null" ] && [ "$description" != "" ]; then
            printf "│ Description: %-66s │\n" "$(echo "$description" | cut -c1-66)"
        fi
        
        printf "│ URL: %-74s │\n" "$(echo "$task_url" | cut -c1-74)"
        
        # Show tags if they exist and were filtered
        if [ -n "$formatted_tags" ]; then
            printf "│ Tags: %-73s │\n" "$(echo "$formatted_tags" | cut -c1-73)"
        fi
        
        # Show AI summary if requested
        if [ -n "$summary_mode" ]; then
            # Show progress indicator for AI summary generation
            show_progress_bar "$task_counter" "$total_tasks"
            
            local task_with_comments=$(get_task_with_comments "$task_id")
            if [ -n "$task_with_comments" ]; then
                case "$summary_mode" in
                    "short")
                        local ai_summary=$(generate_short_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                        if [ $? -eq 0 ] && [ -n "$ai_summary" ]; then
                            # Clear progress line and show summary
                            echo -ne "\r\033[K" >&2
                            printf "│ %-79s │\n" "Summary:"
                            wrap_text_for_table "$ai_summary"
                        else
                            echo -ne "\r\033[K" >&2
                        fi
                        ;;
                    "long")
                        local ai_summary=$(generate_long_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                        if [ $? -eq 0 ] && [ -n "$ai_summary" ]; then
                            # Clear progress line and show summary
                            echo -ne "\r\033[K" >&2
                            # Check if tags were displayed to determine separator placement
                            local has_tags="false"
                            if [ -n "$formatted_tags" ]; then
                                has_tags="true"
                            fi
                            format_long_summary "$ai_summary" "$has_tags"
                        else
                            echo -ne "\r\033[K" >&2
                        fi
                        ;;
                esac
            else
                echo -ne "\r\033[K" >&2
            fi
        fi
        
        printf "└─────────────────────────────────────────────────────────────────────────────────┘\n"
        echo
    done <<< "$(echo "$tasks_data" | jq -c '.[]')"
    
    # Clear any remaining progress indicator
    if [ -n "$summary_mode" ] && [ "$total_tasks" -gt 0 ]; then
        echo -ne "\r\033[K" >&2
    fi
}

# Function to find task by title
find_task_by_title() {
    local search_title="$1"
    local project_id=$(select_project)
    
    if [ $? -ne 0 ] || [ -z "$project_id" ]; then
        echo "Error: No project selected. Please run 'tw' to select a project first." >&2
        return 1
    fi
    
    # Try to load from cache first
    local cache_key="tasks_${project_id}_${USER_ID}"
    local cache_file=$(get_cache_file "$cache_key")
    
    if ! is_cache_valid "$cache_file"; then
        echo "Error: No cached task data available. Please run 'tw tasks' first." >&2
        return 1
    fi
    
    local response=$(cat "$cache_file")
    
    # Search for task by title (case insensitive partial match)
    local search_lower=$(echo "$search_title" | tr '[:upper:]' '[:lower:]')
    local found_tasks=$(echo "$response" | jq -r --arg user_id "$USER_ID" --arg search "$search_lower" '
        .tasks[]
        | select(.assigneeUserIds[]? == ($user_id | tonumber))
        | select(.name | ascii_downcase | contains($search))
        | {id: .id, name: .name}
    ' | jq -s '.')
    
    local task_count=$(echo "$found_tasks" | jq 'length')
    
    if [ "$task_count" -eq 0 ]; then
        echo "Error: No tasks found matching '$search_title'" >&2
        return 1
    elif [ "$task_count" -eq 1 ]; then
        echo "$found_tasks" | jq -r '.[0].id'
        return 0
    else
        echo "Error: Multiple tasks found matching '$search_title':" >&2
        echo "$found_tasks" | jq -r '.[] | "  ID: \(.id) - \(.name)"' >&2
        echo "Please be more specific or use the task ID directly." >&2
        return 1
    fi
}

# Function to open task in browser
open_task() {
    local input="$1"
    shift # Remove first argument, rest will be treated as part of title if needed
    
    # Check for flags in remaining arguments and build complete title
    local remaining_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --*)
                # Skip flags for open command
                shift
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    if [ -z "$input" ]; then
        echo "Error: Task ID or title is required"
        echo "Usage: tw open {ID|Title}"
        exit 1
    fi
    
    local task_id=""
    
    # Check if input is numeric (task ID)
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        task_id="$input"
    else
        # Combine input with remaining args as the task title search
        local search_title="$input"
        if [ ${#remaining_args[@]} -gt 0 ]; then
            search_title="$input ${remaining_args[*]}"
        fi
        
        echo "Searching for task: '$search_title'..."
        task_id=$(find_task_by_title "$search_title")
        
        if [ $? -ne 0 ] || [ -z "$task_id" ]; then
            exit 1
        fi
        
        echo "Found task ID: $task_id"
    fi
    
    # Build task URL
    local task_url="$TEAMWORK_URL/app/tasks/$task_id"
    echo "Opening task in browser: $task_url"
    
    # Open the URL in the default browser
    if command -v open &> /dev/null; then
        # macOS
        open "$task_url"
    elif command -v xdg-open &> /dev/null; then
        # Linux
        xdg-open "$task_url"
    elif command -v start &> /dev/null; then
        # Windows
        start "$task_url"
    else
        echo "Could not automatically open browser. Please manually open:"
        echo "$task_url"
    fi
}

# Function to get activity/timeline for the user
get_activity() {
    echo "Activity feature not yet implemented."
}

# Function to show help
show_help() {
    cat << EOF
Teamwork CLI (tw) - Command-line interface for Teamwork.com

USAGE:
    tw                      Interactive project selection wizard
    tw tasks [options]      List tasks assigned to you  
    tw task {ID|Title}      View single task details with optional AI summary
    tw open {ID|Title}      Open task in browser automatically
    tw summary {ID|Title}   Generate detailed AI summary for specific task
    tw action {ID}          Mark task as actioned (shows green [ACTIONED] status)
    tw unaction {ID}        Remove actioned status from task
    tw refresh              Clear all cached data
    tw refresh {ID}         Clear cache for specific task only
    tw flags                Show this help message

TASK OPTIONS (for 'tasks' command):
    --priority=VALUE     Filter by priority (high, medium, low, normal)
    --due=VALUE          Filter by due date (today, overdue, DD/MM/YYYY, YYYY-MM-DD)
    --start=VALUE        Filter by start date (today, DD/MM/YYYY, YYYY-MM-DD)  
    --tags=VALUE         Filter by tag name (case insensitive)
    --order=VALUE        Sort tasks by: priority, lastupdated, duedate, start (default: duedate)
    --summary            Add short AI summaries to task list
    --summary=long       Add detailed AI summaries to task list
    --debug              Show debug information about API data extraction
    --no-clear           Skip resetting the terminal before displaying tasks

SINGLE TASK OPTIONS (for 'task' command):
    --summary            Add short AI summary to task display
    --summary=long       Add detailed AI summary to task display
    --comments           Show all comments for the task
    --comments=N         Show latest N comments (e.g., --comments=3)
    --debug              Show debug information about API data extraction

FEATURES:
    - Project scope selection with "ALL PROJECTS" option
    - Smart caching with automatic refresh detection
    - Task search by title or ID for URL display
    - Clean terminal output with structured formatting
    - Full task details including priority, dates, descriptions, and URLs
    - AI-powered task summaries using Claude (requires claude CLI)
    - Task status indicators: [ACTIONED] (green) and [RECENTLY UPDATED] (yellow)
    - Persistent actioned status tracking with automatic invalidation on task updates

EXAMPLES:
    tw                              # Select project interactively
    tw tasks                        # List all tasks (ordered by due date)
    tw tasks --order=priority       # List tasks ordered by priority (high first)
    tw tasks --order=lastupdated    # List tasks ordered by last update
    tw tasks --summary              # List tasks with short AI summaries
    tw tasks --summary=long         # List tasks with detailed AI summaries
    tw tasks --priority=high        # Show only high priority tasks
    tw tasks --due=today            # Show tasks due today
    tw tasks --due=overdue          # Show overdue tasks
    tw tasks --order=start --summary # Show tasks by start date with summaries
    tw tasks --no-clear             # List tasks without resetting terminal first
    tw task 123456                  # View single task details by ID
    tw task "Fix login bug"         # View single task details by title search
    tw task 123456 --summary        # View single task with short AI summary
    tw task "Fix login bug" --summary=long # View single task with detailed AI summary
    tw task 123456 --comments       # View single task with all comments
    tw task 123456 --comments=3     # View single task with latest 3 comments
    tw summary 123456               # Get detailed AI summary for task
    tw summary "Fix login bug"      # Get AI summary by task title
    tw open 123456                  # Open task in browser by ID
    tw open "Fix login bug"         # Open task in browser by title search
    tw action 123456                # Mark task as actioned
    tw unaction 123456              # Remove actioned status
    tw refresh                      # Clear all cached data
    tw refresh 123456               # Clear cache for specific task only

CONFIGURATION:
    Environment file: ~/.tw.env or ./.env
    Required variables: TEAMWORK_URL, API_KEY, PASSWORD, USER_ID

EOF
}

# Function to format and display task comments
format_task_comments() {
    local task_id="$1"
    local comments_limit="$2"
    
    # Fetch comments for the task
    local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
    local page_size="50"  # Default to 50, will be adjusted based on limit
    
    # Adjust page size based on limit - but ensure we get enough to sort properly
    if [ "$comments_limit" != "all" ] && [[ "$comments_limit" =~ ^[0-9]+$ ]]; then
        # Get a bit more than requested to ensure we can sort and limit properly
        local requested_limit="$comments_limit"
        if [ "$requested_limit" -lt 50 ]; then
            page_size="50"  # Get more than needed to ensure proper sorting
        else
            page_size="$requested_limit"
        fi
    fi
    
    # Use same approach as existing function but with descending order
    local comments_response=$(curl -s -H "$auth_header" \
        "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/comments.json?pageSize=$page_size&orderMode=desc" 2>/dev/null | sed 's/\\r//g; s/\\n/ /g')
    
    if [ $? -ne 0 ] || [ -z "$comments_response" ]; then
        echo "Comments: Unable to fetch comments"
        return 1
    fi
    
    # Check for API errors
    local error=$(echo "$comments_response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "Comments: API Error - $error"
        return 1
    fi
    
    # Validate limit before processing
    if [ "$comments_limit" != "all" ] && ! [[ "$comments_limit" =~ ^[0-9]+$ ]]; then
        echo "Comments: Invalid limit '$comments_limit' (use 'all' or a number)"
        return 1
    fi
    
    # Extract comments data
    local comments_data=$(echo "$comments_response" | jq -r '.comments // []')
    local total_comments=$(echo "$comments_data" | jq 'length')
    
    if [ "$total_comments" -eq 0 ]; then
        echo "Comments: No comments found"
        return 0
    fi
    
    # Apply limit if specified
    local display_comments=""
    if [ "$comments_limit" = "all" ]; then
        display_comments="$comments_data"
        printf "│ %-79s │\n" "Comments: ($total_comments total)"
    elif [[ "$comments_limit" =~ ^[0-9]+$ ]]; then
        local limit_num="$comments_limit"
        if [ "$limit_num" -ge "$total_comments" ]; then
            display_comments="$comments_data"
            printf "│ %-79s │\n" "Comments: (showing all $total_comments)"
        else
            # Take the latest N comments (comments are usually returned in reverse chronological order)
            display_comments=$(echo "$comments_data" | jq ".[0:$limit_num]")
            printf "│ %-79s │\n" "Comments: (showing latest $limit_num of $total_comments)"
        fi
    fi
    
    # Add table header for comments
    printf "├───────────────────────────┬─────────────────┬───────────────────────────────────┤\n"
    printf "│ %-25s │ %-15s │ %-33s │\n" "Date" "Author" "Content"
    printf "├───────────────────────────┼─────────────────┼───────────────────────────────────┤\n"
    
    # Note: Author information will be extracted directly from comment objects
    
    # Format and display each comment in table format
    echo "$display_comments" | jq -r '.[] | 
        (.postedDateTime // .createdDate // .dateCreated // "Unknown date") + "|" + 
        (
            # Try the most common Teamwork API field patterns
            if (.author | type == "object") and (.author.firstName // .author.lastName // .author.name // "") != "" then
                ((.author.firstName // "") + " " + (.author.lastName // "")) | gsub("  "; " ") | gsub("^ | $"; "") | if . == "" then (.author.name // "Unknown User") else . end
            elif (.postedBy | type == "object") and (.postedBy.firstName // .postedBy.lastName // .postedBy.name // "") != "" then
                ((.postedBy.firstName // "") + " " + (.postedBy.lastName // "")) | gsub("  "; " ") | gsub("^ | $"; "") | if . == "" then (.postedBy.name // "Unknown User") else . end
            elif (.createdBy | type == "object") and (.createdBy.firstName // .createdBy.lastName // .createdBy.name // "") != "" then
                ((.createdBy.firstName // "") + " " + (.createdBy.lastName // "")) | gsub("  "; " ") | gsub("^ | $"; "") | if . == "" then (.createdBy.name // "Unknown User") else . end
            elif (.user | type == "object") and (.user.firstName // .user.lastName // .user.name // "") != "" then
                ((.user.firstName // "") + " " + (.user.lastName // "")) | gsub("  "; " ") | gsub("^ | $"; "") | if . == "" then (.user.name // "Unknown User") else . end
            elif (.authorName // .userName // .createdByName // .postedByName // "") != "" then
                (.authorName // .userName // .createdByName // .postedByName)
            else
                "Unknown User"
            end
        ) + "|" + 
        (.body // "No content")' | while IFS='|' read -r date_part author_part content_part; do
        
        # Format dates if they look like ISO dates
        local formatted_date="$date_part"
        if [[ "$date_part" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2} ]]; then
            if [[ "$date_part" =~ Z$ ]]; then
                formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$date_part" "+%b %d, %Y at %I:%M %p" 2>/dev/null)
            elif [[ "$date_part" =~ \+[0-9]{2}:[0-9]{2}$ ]]; then
                # Handle timezone offset format
                formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "${date_part//:}" "+%b %d, %Y at %I:%M %p" 2>/dev/null)
            else
                # Try basic format without timezone
                formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$date_part" "+%b %d, %Y at %I:%M %p" 2>/dev/null)
            fi
            
            if [ -z "$formatted_date" ]; then
                formatted_date="$date_part"
            fi
        fi
        
        # Display comment in table format with full content
        local date_display="$(echo "$formatted_date" | cut -c1-25)"
        local author_display="$(echo "$author_part" | cut -c1-15)"
        
        # For content, split into multiple lines if needed
        local content_lines=()
        local remaining_content="$content_part"
        
        # Split content into chunks that fit in the content column (33 chars)
        while [ ${#remaining_content} -gt 33 ]; do
            local chunk="${remaining_content:0:33}"
            
            # Try to break at word boundary by finding the last space within the chunk
            local break_pos=33
            local temp_chunk="$chunk"
            
            # Look for the last space character within reasonable distance from the end
            for ((pos=33; pos>=18; pos--)); do
                if [ "${remaining_content:$((pos-1)):1}" = " " ]; then
                    break_pos=$pos
                    break
                fi
            done
            
            # Extract the chunk and update remaining content
            chunk="${remaining_content:0:$break_pos}"
            
            # Skip the space if we broke at a word boundary
            if [ "${remaining_content:$((break_pos-1)):1}" = " " ]; then
                remaining_content="${remaining_content:$break_pos}"
            else
                remaining_content="${remaining_content:$break_pos}"
            fi
            
            # Trim trailing spaces from chunk
            chunk="${chunk%"${chunk##*[![:space:]]}"}"
            content_lines+=("$chunk")
        done
        
        # Add remaining content
        if [ -n "$remaining_content" ]; then
            content_lines+=("$remaining_content")
        fi
        
        # Display first line with date and author
        printf "│ %-25s │ %-15s │ %-33s │\n" "$date_display" "$author_display" "${content_lines[0]:-}"
        
        # Display additional content lines
        for ((i=1; i<${#content_lines[@]}; i++)); do
            printf "│ %-25s │ %-15s │ %-33s │\n" "" "" "${content_lines[i]}"
        done
        
        # Add visual separator after each comment
        printf "├───────────────────────────┼─────────────────┼───────────────────────────────────┤\n"
    done
}

# Function to show single task details
show_single_task() {
    local input="$1"
    shift # Remove first argument, rest will be treated as options or part of title
    
    # Parse flags
    local summary_mode=""
    local debug_mode="false"
    local comments_mode=""
    local comments_limit=""
    local remaining_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --summary=*)
                summary_mode="${1#*=}"
                shift
                ;;
            --summary)
                summary_mode="short"
                shift
                ;;
            --comments=*)
                comments_mode="true"
                comments_limit="${1#*=}"
                shift
                ;;
            --comments)
                comments_mode="true"
                comments_limit="all"
                shift
                ;;
            --debug)
                debug_mode="true"
                shift
                ;;
            --help)
                echo "Use 'tw flags' to see available commands and options."
                return 0
                ;;
            --*)
                echo "Unknown option: $1"
                echo "Use 'tw task --help' for usage information."
                return 1
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Handle help flag as first argument
    if [ "$input" = "--help" ]; then
        echo "Use 'tw flags' to see available commands and options."
        return 0
    fi
    
    if [ -z "$input" ]; then
        echo "Error: Task ID or title is required"
        echo "Usage: tw task {ID|Title} [options]"
        return 1
    fi
    
    local task_id=""
    
    # Check if input is numeric (task ID)
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        task_id="$input"
    else
        # Combine input with remaining args as the task title search
        local search_title="$input"
        if [ ${#remaining_args[@]} -gt 0 ]; then
            search_title="$input ${remaining_args[*]}"
        fi
        
        echo "Searching for task: '$search_title'..."
        task_id=$(find_task_by_title "$search_title")
        
        if [ $? -ne 0 ] || [ -z "$task_id" ]; then
            return 1
        fi
    fi
    
    # Fetch task details from cache or API
    local project_id=$(select_project)
    if [ $? -ne 0 ] || [ -z "$project_id" ]; then
        echo "Error: No project selected. Please run 'tw' to select a project first."
        return 1
    fi
    
    # Try to get task from cache
    local cache_key="tasks_${project_id}_${USER_ID}"
    local cache_file=$(get_cache_file "$cache_key")
    local task_data=""
    
    if is_cache_valid "$cache_file"; then
        local response=$(cat "$cache_file")
        task_data=$(echo "$response" | jq -r --arg task_id "$task_id" '.tasks[] | select(.id == ($task_id | tonumber))')
    fi
    
    # If not found in cache or cache invalid, fetch directly
    if [ -z "$task_data" ] || [ "$task_data" = "null" ]; then
        local auth_header="Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
        local response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id.json")
        
        if [ $? -ne 0 ]; then
            echo "Error: Failed to fetch task from Teamwork API"
            return 1
        fi
        
        local error=$(echo "$response" | jq -r '.error // empty')
        if [ -n "$error" ]; then
            echo "API Error: $error"
            return 1
        fi
        
        task_data=$(echo "$response" | jq -r '.task')
    fi
    
    # Extract task details
    local task_name=$(echo "$task_data" | jq -r '.name // "Unknown Task"')
    local due_date=$(echo "$task_data" | jq -r '.dueDate // "No due date"')
    local start_date=$(echo "$task_data" | jq -r '.startDate // "No start date"')
    local priority=$(echo "$task_data" | jq -r '.priority // "Normal"')
    local description=$(echo "$task_data" | jq -r '.description // ""')
    local tag_ids=$(echo "$task_data" | jq -r '.tagIds // "[]"')
    local updated_at=$(echo "$task_data" | jq -r '.updatedAt // ""')
    
    # Format dates
    local formatted_due=$(echo "$due_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$due_date")
    local formatted_start=$(echo "$start_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$start_date")
    
    # Format tags if present
    local formatted_tags=""
    if [ "$tag_ids" != "[]" ] && [ "$tag_ids" != "null" ]; then
        local tags_lookup=$(fetch_tags "$project_id")
        formatted_tags=$(format_tags "$tag_ids" "$tags_lookup")
    fi
    
    # Priority display
    local priority_display="NORMAL"
    case "$priority" in
        "high") priority_display="HIGH" ;;
        "medium") priority_display="MEDIUM" ;;
        "low") priority_display="LOW" ;;
        *) priority_display="NORMAL" ;;
    esac
    
    # Format priority with color
    local formatted_priority=$(format_priority "$priority_display")
    
    # Format due date with overdue check
    local formatted_due_with_color=$(format_due_date "$due_date" "$formatted_due")
    
    # Format task title in bold with status indicators
    local formatted_title=$(format_task_title "$task_name" "$task_id" "$updated_at")
    
    # Build task URL
    local task_url="$TEAMWORK_URL/app/tasks/$task_id"
    
    # Display task details in table format
    printf "┌─────────────────────────────────────────────────────────────────────────────────┐\n"
    echo "│ $(pad_colored_text "$formatted_title" 79) │"
    printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
    # Format with proper padding for colored text
    local id_part="ID: $task_id"
    local priority_padded=$(pad_colored_text "$formatted_priority" 20)
    local due_padded=$(pad_colored_text "$formatted_due_with_color" 36)
    echo "│ $(printf "%-15s" "$id_part") │ $priority_padded │ $due_padded │"
    
    # Show start date if set
    if [ "$start_date" != "No start date" ] && [ "$start_date" != "null" ]; then
        printf "│ Start: %-72s │\n" "$(echo "$formatted_start" | cut -c1-72)"
    fi
    
    # Show description if it exists
    if [ -n "$description" ] && [ "$description" != "null" ] && [ "$description" != "" ]; then
        printf "│ Description: %-66s │\n" "$(echo "$description" | cut -c1-66)"
    fi
    
    printf "│ URL: %-74s │\n" "$(echo "$task_url" | cut -c1-74)"
    
    # Show tags if they exist
    if [ -n "$formatted_tags" ]; then
        printf "│ Tags: %-73s │\n" "$(echo "$formatted_tags" | cut -c1-73)"
    fi
    
    # Show AI summary if requested
    if [ -n "$summary_mode" ]; then
        local task_with_comments=$(get_task_with_comments "$task_id")
        if [ -n "$task_with_comments" ]; then
            case "$summary_mode" in
                "short")
                    echo -ne "Generating AI summary..." >&2
                    local ai_summary=$(generate_short_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                    echo -ne "\r\033[K" >&2
                    if [ $? -eq 0 ] && [ -n "$ai_summary" ]; then
                        printf "│ %-79s │\n" "Summary:"
                        wrap_text_for_table "$ai_summary"
                    fi
                    ;;
                "long")
                    echo -ne "Generating AI summary..." >&2
                    local ai_summary=$(generate_long_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                    echo -ne "\r\033[K" >&2
                    if [ $? -eq 0 ] && [ -n "$ai_summary" ]; then
                        # Check if tags were displayed to determine separator placement
                        local has_tags="false"
                        if [ -n "$formatted_tags" ]; then
                            has_tags="true"
                        fi
                        format_long_summary "$ai_summary" "$has_tags"
                    fi
                    ;;
            esac
        fi
    fi
    
    # Show comments if requested
    if [ -n "$comments_mode" ]; then
        printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
        format_task_comments "$task_id" "$comments_limit"
    fi
    
    printf "└─────────────────────────────────────────────────────────────────────────────────┘\n"
    echo
}

# Function to show detailed summary for a specific task
show_task_summary() {
    local input="$1"
    shift # Remove first argument
    
    local task_id=""
    
    # Check if input is a number (task ID) or text (task title)
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        task_id="$input"
    else
        # Search for task by title
        local search_results=$(find_task_by_title "$input")
        if [ $? -ne 0 ] || [ -z "$search_results" ]; then
            echo "Error: Task not found with title containing: $input"
            return 1
        fi
        
        # Extract task ID from search results
        task_id=$(echo "$search_results" | jq -r '.[0].id' 2>/dev/null)
        if [ -z "$task_id" ] || [ "$task_id" = "null" ]; then
            echo "Error: Could not find task with title: $input"
            return 1
        fi
    fi
    
    # Fetch task with comments
    local task_with_comments=$(get_task_with_comments "$task_id")
    if [ $? -ne 0 ] || [ -z "$task_with_comments" ]; then
        echo "Error: Could not fetch task details for ID: $task_id"
        return 1
    fi
    
    # Extract basic task info
    local task_name=$(echo "$task_with_comments" | jq -r '.task.name // "Unknown Task"')
    local priority=$(echo "$task_with_comments" | jq -r '.task.priority // "Normal"')
    local due_date=$(echo "$task_with_comments" | jq -r '.task.dueDate // "Not set"')
    local updated_at=$(echo "$task_with_comments" | jq -r '.task.updatedAt // ""')
    
    # Format due date
    local formatted_due="$due_date"
    if [ "$due_date" != "Not set" ] && [ "$due_date" != "null" ]; then
        formatted_due=$(echo "$due_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$due_date")
    fi
    
    # Format priority display
    local priority_display="NORMAL"
    case "$priority" in
        "high") priority_display="HIGH" ;;
        "medium") priority_display="MEDIUM" ;;
        "low") priority_display="LOW" ;;
        *) priority_display="NORMAL" ;;
    esac
    
    # Format priority with color
    local formatted_priority=$(format_priority "$priority_display")
    
    # Format due date with overdue check
    local formatted_due_with_color=$(format_due_date "$due_date" "$formatted_due")
    
    # Format task title in bold with status indicators
    local formatted_title=$(format_task_title "$task_name" "$task_id" "$updated_at")
    
    # Display task header in table format
    printf "┌─────────────────────────────────────────────────────────────────────────────────┐\n"
    echo "│ $(pad_colored_text "$formatted_title" 79) │"
    printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
    # Format with proper padding for colored text
    local id_part="ID: $task_id"
    local priority_padded=$(pad_colored_text "$formatted_priority" 20)
    local due_padded=$(pad_colored_text "$formatted_due_with_color" 36)
    echo "│ $(printf "%-15s" "$id_part") │ $priority_padded │ $due_padded │"
    printf "├─────────────────────────────────────────────────────────────────────────────────┤\n"
    
    # Generate and display long AI summary
    echo -ne "Generating AI summary..." >&2
    local ai_summary=$(generate_long_summary "$task_with_comments" "$task_id" "$updated_at")
    echo -ne "\r\033[K" >&2  # Clear the progress line
    
    if [ $? -eq 0 ] && [ -n "$ai_summary" ]; then
        echo "$ai_summary" | while IFS= read -r line; do
            printf "│ %-79s │\n" "$(echo "$line" | cut -c1-79)"
        done
    else
        printf "│ %-79s │\n" "AI summary unavailable"
    fi
    
    printf "└─────────────────────────────────────────────────────────────────────────────────┘\n"
}

# Main command dispatcher
case "${1:-}" in
    "tasks")
        get_tasks "$@"
        ;;
    "task")
        if [ -z "$2" ]; then
            echo "Error: Task ID or title is required"
            echo "Usage: tw task {ID|Title} [options]"
            exit 1
        fi
        shift # Remove 'task'
        show_single_task "$@"
        ;;
    "open")
        if [ -z "$2" ]; then
            echo "Error: Task ID or title is required"
            echo "Usage: tw open {ID|Title}"
            exit 1
        fi
        shift # Remove 'open'
        open_task "$@"
        ;;
    "summary")
        if [ -z "$2" ]; then
            echo "Error: Task ID or title is required"
            echo "Usage: tw summary {ID|Title}"
            exit 1
        fi
        shift # Remove 'summary'
        show_task_summary "$@"
        ;;
    "activity")
        get_activity
        ;;
    "action")
        if [ -z "$2" ]; then
            echo "Error: Task ID is required"
            echo "Usage: tw action {task_id}"
            exit 1
        fi
        shift # Remove 'action'
        mark_task_actioned "$1"
        ;;
    "unaction")
        if [ -z "$2" ]; then
            echo "Error: Task ID is required"
            echo "Usage: tw unaction {task_id}"
            exit 1
        fi
        shift # Remove 'unaction'
        unmark_task_actioned "$1"
        ;;
    "refresh")
        if [ -n "$2" ]; then
            # Single task cache refresh
            shift # Remove 'refresh'
            clear_task_cache "$1"
        else
            # Clear all cache
            clear_cache
        fi
        ;;
    "flags"|"help"|"--help")
        show_help
        ;;
    "")
        # No arguments - run project wizard
        project_wizard
        ;;
    *)
        echo "Unknown command: $1"
        echo "Use 'tw flags' to see available commands."
        exit 1
        ;;
esac