#!/bin/bash

# Teamwork.com CLI Tool
# Usage: tw <command>

set -e

# Cleanup function
cleanup() {
    # Kill spinner if it's running
    if [ -n "$SPINNER_PID" ]; then
        kill $SPINNER_PID 2>/dev/null
        wait $SPINNER_PID 2>/dev/null
        printf "\r\033[K" >&2
    fi
}

# Set trap to cleanup on exit
trap cleanup EXIT INT TERM

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Cache directory
CACHE_DIR="/tmp/.tw_cache"
mkdir -p "$CACHE_DIR"

# Cache expiry time in seconds (30 minutes)
CACHE_EXPIRY=1800

# Spinner characters
SPINNER_CHARS="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
SPINNER_PID=""

# Function to show spinner
show_spinner() {
    local message="$1"
    local i=0
    # Check if parent process is still alive
    while kill -0 $$ 2>/dev/null; do
        printf "\r%s %s" "${SPINNER_CHARS:i:1}" "$message" >&2
        i=$(( (i + 1) % ${#SPINNER_CHARS} ))
        sleep 0.1
    done
}

# Function to start spinner in background
start_spinner() {
    # Stop any existing spinner first
    stop_spinner
    
    local message="${1:-Loading...}"
    
    # Only start spinner if stderr is a terminal
    if [ -t 2 ]; then
        show_spinner "$message" &
        SPINNER_PID=$!
        disown $SPINNER_PID 2>/dev/null  # Disown to prevent hang on exit
    fi
}

# Function to stop spinner
stop_spinner() {
    if [ -n "$SPINNER_PID" ]; then
        # Kill the spinner process
        kill $SPINNER_PID 2>/dev/null
        # Don't wait for it since we disowned it
        SPINNER_PID=""
        printf "\r\033[K" >&2  # Clear the line
    fi
}

# Function to update spinner message dynamically
update_spinner() {
    local new_message="$1"
    if [ -n "$SPINNER_PID" ] && [ -t 2 ]; then
        # Stop current spinner
        kill $SPINNER_PID 2>/dev/null
        # Start new one with updated message
        show_spinner "$new_message" &
        SPINNER_PID=$!
        disown $SPINNER_PID 2>/dev/null
    elif [ -t 2 ]; then
        # Start spinner if none running
        start_spinner "$new_message"
    fi
}

# Function to get cache file path
get_cache_file() {
    local cache_key="$1"
    echo "$CACHE_DIR/${cache_key}.json"
}

# Function to check if cache is valid
is_cache_valid() {
    local cache_file="$1"
    local task_updated_at="$2"  # Optional - if provided, use task-based validation
    
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    # If task_updated_at is provided, use task-based validation (infinite cache unless task updated)
    if [ -n "$task_updated_at" ]; then
        # Check if cache metadata file exists
        local cache_meta_file="${cache_file}.meta"
        if [ ! -f "$cache_meta_file" ]; then
            return 1  # No metadata, cache invalid
        fi
        
        # Read cached task updatedAt timestamp
        local cached_updated_at=$(cat "$cache_meta_file" 2>/dev/null)
        
        # Compare timestamps - cache valid if task hasn't been updated since cache creation
        [ "$cached_updated_at" = "$task_updated_at" ]
    else
        # Fall back to time-based validation for non-task cache (projects, etc.)
        local cache_time=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null)
        local current_time=$(date +%s)
        local age=$((current_time - cache_time))
        
        [ $age -lt $CACHE_EXPIRY ]
    fi
}

# Function to save to cache
save_to_cache() {
    local cache_key="$1"
    local data="$2"
    local task_updated_at="$3"  # Optional - if provided, save task metadata
    local cache_file=$(get_cache_file "$cache_key")
    
    echo "$data" > "$cache_file"
    
    # If task_updated_at is provided, save metadata for task-based cache validation
    if [ -n "$task_updated_at" ]; then
        local cache_meta_file="${cache_file}.meta"
        echo "$task_updated_at" > "$cache_meta_file"
    fi
}

# Function to load from cache
load_from_cache() {
    local cache_key="$1"
    local cache_file=$(get_cache_file "$cache_key")
    
    if is_cache_valid "$cache_file"; then
        cat "$cache_file"
        return 0
    else
        return 1
    fi
}

# Function to clear all cache
clear_cache() {
    rm -rf "$CACHE_DIR"
    mkdir -p "$CACHE_DIR"
    echo "Cache cleared successfully."
}

# Function to mark a task as actioned
mark_task_actioned() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        echo "Usage: tw action {task_id}"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    # First, fetch the current task to get its updatedAt timestamp
    local auth_header=$(get_auth_header)
    local task_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id.json" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$task_response" ]; then
        echo "Error: Failed to fetch task $task_id from Teamwork API"
        return 1
    fi
    
    # Check if response contains error
    local error=$(echo "$task_response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "API Error: $error"
        return 1
    fi
    
    # Extract task details
    local task_name=$(echo "$task_response" | jq -r '.task.name // "Unknown Task"')
    local updated_at=$(echo "$task_response" | jq -r '.task.updatedAt // ""')
    
    if [ -z "$updated_at" ] || [ "$updated_at" = "null" ]; then
        echo "Error: Could not get task update timestamp"
        return 1
    fi
    
    # Save actioned status with timestamp
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    local actioned_data=$(jq -n --arg task_id "$task_id" --arg updated_at "$updated_at" --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '{
        taskId: $task_id,
        actionedAt: $timestamp,
        lastUpdatedAt: $updated_at
    }')
    
    echo "$actioned_data" > "$actioned_file"
    echo "Task $task_id marked as actioned: $task_name"
}

# Function to check if a task is marked as actioned and still valid
is_task_actioned() {
    local task_id="$1"
    local current_updated_at="$2"
    
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    
    if [ ! -f "$actioned_file" ]; then
        return 1  # Not actioned
    fi
    
    # Read the stored actioned data
    local stored_updated_at=$(cat "$actioned_file" | jq -r '.lastUpdatedAt // ""')
    
    # If current_updated_at is different from stored, the actioned status is invalid
    if [ "$current_updated_at" != "$stored_updated_at" ]; then
        # Remove the outdated actioned file
        rm "$actioned_file"
        return 1  # No longer valid
    fi
    
    return 0  # Still actioned and valid
}

# Function to remove actioned status for a task
unmark_task_actioned() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        echo "Usage: tw unaction {task_id}"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    
    if [ -f "$actioned_file" ]; then
        rm "$actioned_file"
        echo "Actioned status removed from task $task_id"
    else
        echo "Task $task_id was not marked as actioned"
    fi
}

# Function to remove actioned status from all tasks
unmark_all_tasks_actioned() {
    local actioned_files=("$CACHE_DIR"/actioned_*.json)
    local count=0
    
    # Check if any actioned files exist
    if [ ! -f "${actioned_files[0]}" ]; then
        echo "No actioned tasks found"
        return 0
    fi
    
    # Remove all actioned files
    for file in "${actioned_files[@]}"; do
        if [ -f "$file" ]; then
            rm "$file"
            ((count++))
        fi
    done
    
    echo "Removed actioned status from $count task(s)"
}

# Function to convert UTC timestamp to specified timezone for display
convert_utc_to_display_timezone() {
    local utc_timestamp="$1"
    local target_timezone="${2:-UTC}"
    
    if [ -z "$utc_timestamp" ] || [ "$utc_timestamp" = "null" ]; then
        echo ""
        return 1
    fi
    
    # If target timezone is UTC, no conversion needed
    if [ "$target_timezone" = "UTC" ]; then
        echo "$utc_timestamp"
        return 0
    fi
    
    # Convert UTC timestamp to target timezone
    local converted_timestamp
    if [[ "$utc_timestamp" =~ Z$ ]]; then
        # Parse UTC timestamp and convert to target timezone
        if converted_timestamp=$(TZ="$target_timezone" date -j -f "%Y-%m-%dT%H:%M:%SZ" "$utc_timestamp" "+%Y-%m-%dT%H:%M:%S" 2>/dev/null); then
            echo "${converted_timestamp}"
        else
            # Fallback to original if conversion fails
            echo "$utc_timestamp"
        fi
    else
        # Return as-is if not in expected format
        echo "$utc_timestamp"
    fi
}








# Function to clear cache for a specific task
clear_task_cache() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        echo "Usage: tw refresh {task_id}"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    local files_removed=0
    
    # Remove AI summary caches for this task (both short and long)
    for cache_file in "$CACHE_DIR"/ai_*_${task_id}_*.json; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed AI summary cache: $(basename "$cache_file")"
        fi
    done
    
    # Remove AI summary metadata files
    for cache_file in "$CACHE_DIR"/ai_*_${task_id}_*.json.meta; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed AI summary metadata: $(basename "$cache_file")"
        fi
    done
    
    # Remove task list caches (since they contain the task data that might be stale)
    # This ensures the task data is refreshed when viewing task lists
    for cache_file in "$CACHE_DIR"/tasks_*_*.json; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed task list cache: $(basename "$cache_file")"
        fi
    done
    
    # Remove task list metadata files
    for cache_file in "$CACHE_DIR"/tasks_*_*.json.meta; do
        if [ -f "$cache_file" ]; then
            rm "$cache_file"
            files_removed=$((files_removed + 1))
            echo "Removed task list metadata: $(basename "$cache_file")"
        fi
    done
    
    # Remove actioned status file for this specific task
    local actioned_file="$CACHE_DIR/actioned_${task_id}.json"
    if [ -f "$actioned_file" ]; then
        rm "$actioned_file"
        files_removed=$((files_removed + 1))
        echo "Removed actioned status: $(basename "$actioned_file")"
    fi
    
    if [ $files_removed -eq 0 ]; then
        echo "No cache files found for task ID: $task_id"
    else
        echo "Cache cleared for task $task_id ($files_removed files removed)."
    fi
}

# Function to check if cached task data is still current by comparing updatedAt timestamps
is_task_data_current() {
    local cache_file="$1"
    local project_id="$2"
    
    # If cache doesn't exist, it's not current
    if [ ! -f "$cache_file" ]; then
        return 1
    fi
    
    # Get the most recent updatedAt from cached tasks and count of tasks
    local cached_updated=$(cat "$cache_file" | jq -r '.tasks // [] | map(.updatedAt // empty) | max // empty' 2>/dev/null)
    local cached_task_count=$(cat "$cache_file" | jq -r '.tasks // [] | length' 2>/dev/null)
    if [ "$cached_updated" = "null" ] || [ -z "$cached_updated" ]; then
        return 1
    fi
    
    # Fetch just basic task info to check updatedAt timestamps
    local auth_header=$(get_auth_header)
    local current_response
    
    if [ "$project_id" = "ALL" ]; then
        current_response=$(curl -s -H "$auth_header" \
            "$TEAMWORK_URL/projects/api/v3/tasks.json?assigneeUserIds=$USER_ID&pageSize=500&fields=id,updatedAt" 2>/dev/null)
    else
        current_response=$(curl -s -H "$auth_header" \
            "$TEAMWORK_URL/projects/api/v3/projects/$project_id/tasks.json?fields=id,updatedAt" 2>/dev/null)
    fi
    
    # Check if API call failed
    if [ $? -ne 0 ] || [ -z "$current_response" ]; then
        # If API call fails, assume cache is still valid to avoid breaking functionality
        return 0
    fi
    
    # Get the most recent updatedAt from current data and count of tasks
    local current_updated=$(echo "$current_response" | jq -r '.tasks // [] | map(.updatedAt // empty) | max // empty' 2>/dev/null)
    local current_task_count=$(echo "$current_response" | jq -r '.tasks // [] | length' 2>/dev/null)
    if [ "$current_updated" = "null" ] || [ -z "$current_updated" ]; then
        # If we can't get current timestamp, assume cache is valid
        return 0
    fi
    
    # Check if task count has decreased (tasks completed/deleted)
    if [ "$current_task_count" -lt "$cached_task_count" ]; then
        # Task count decreased - cache is invalid
        return 1
    fi
    
    # Compare timestamps - return 0 if they match (current), 1 if different (not current)
    if [ "$cached_updated" = "$current_updated" ]; then
        return 0  # Data is current
    else
        return 1  # Data is not current
    fi
}


# Function to show first-time welcome message
show_welcome_message() {
    local welcome_flag_file="$CACHE_DIR/.tw_welcome_shown"
    
    # Check if welcome message has already been shown
    if [ -f "$welcome_flag_file" ]; then
        return 0  # Already shown, skip
    fi
    
    # Display welcome message in clean format
    printf "\n"
    printf "  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
    printf "\n"
    printf "\033[1m                        WELCOME TO TEAMWORK CLI                        \033[0m\n"
    printf "\n"
    printf "   \033[92m✓\033[0m Modern command-line interface for Teamwork.com\n"
    printf "   \033[92m✓\033[0m AI-powered task summaries and smart filtering\n"
    printf "   \033[92m✓\033[0m Clean terminal output and intuitive commands\n"
    printf "\n"
    printf "   \033[1mCreated by:\033[0m Anthony Keal\n"
    printf "   \033[1mContact:\033[0m contact@business.anthonykeal.com.au\n"
    printf "\n"
    printf "   \033[93m➤\033[0m \033[1mGet Started:\033[0m Run 'tw flags' to see all available commands\n"
    printf "   \033[93m➤\033[0m \033[1mSupport:\033[0m https://buymeacoffee.com/anthonykeal\n"
    printf "\n"
    printf "  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
    echo
    
    # Create flag file to mark welcome message as shown
    touch "$welcome_flag_file"
    
    # Pause briefly to let user read the message
    echo "Press any key to continue..."
    read -n 1 -s
    echo
}

# Function to check if Claude CLI is available
check_claude_available() {
    if ! command -v claude &> /dev/null; then
        return 1
    fi
    return 0
}

# Removed progress bar function - using spinner instead

# Function to fetch task with latest 5 comments for AI context
get_task_with_comments() {
    local task_id="$1"
    local auth_header=$(get_auth_header)
    
    # Fetch task details - clean control characters that break JSON parsing
    local task_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id.json" 2>/dev/null | sed 's/\\r//g; s/\\n/ /g')
    if [ $? -ne 0 ] || [ -z "$task_response" ]; then
        echo ""
        return 1
    fi
    
    # Fetch latest 5 comments in descending order (most recent first) - clean control characters
    local comments_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/comments.json?pageSize=5&orderMode=desc" 2>/dev/null | sed 's/\\r//g; s/\\n/ /g')
    
    # Combine task and comments data
    local combined_data=$(jq -n \
        --argjson task "$task_response" \
        --argjson comments "$comments_response" \
        '{task: $task.task, comments: $comments.comments}')
    
    echo "$combined_data"
}

# Function to generate short AI summary (1-2 sentences)
generate_short_summary() {
    local task_data="$1"
    local task_id="$2"
    local last_updated="$3"
    local debug_mode="${4:-false}"
    
    if ! check_claude_available; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Check cache first
    local cache_key="ai_short_${task_id}_${last_updated}"
    local cache_file=$(get_cache_file "$cache_key")
    
    if [ -f "$cache_file" ]; then
        cat "$cache_file"
        return 0
    fi
    
    # Extract task and comment information for AI
    local task_name=$(echo "$task_data" | jq -r '.task.name // "Unknown Task"')
    local task_description=$(echo "$task_data" | jq -r '.task.description // ""' | sed 's/<[^>]*>//g' | sed 's/|[[:space:]]*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    local comments=$(echo "$task_data" | jq -r '.comments[]? | "- " + (.body // "")' | head -5)
    local comment_count=$(echo "$task_data" | jq '.comments | length')
    
    # Check if task is empty (no description and no comments)
    if [ -z "$task_description" ] || [ "$task_description" = "null" ] || [ "$task_description" = "" ]; then
        if [ "$comment_count" -eq 0 ] || [ -z "$comments" ]; then
            local empty_summary="Empty task"
            echo "$empty_summary" > "$cache_file"
            echo "$empty_summary"
            return 0
        fi
    fi
    
    # Debug output if requested
    if [ "$debug_mode" = "true" ]; then
        echo "=== DEBUG: Task Data Structure ===" >&2
        echo "Task Name: $task_name" >&2
        echo "Task Description: $task_description" >&2
        echo "Comments Count: $(echo "$task_data" | jq '.comments | length')" >&2
        echo "Comments:" >&2
        echo "$comments" >&2
        echo "=== END DEBUG ===" >&2
    fi
    
    # Build AI prompt with clear context labels
    local prompt="You are analyzing a Teamwork task assigned to you. Carefully read the task title, description, and recent comments to understand the current status and what you need to know.

TASK TITLE: $task_name

TASK DESCRIPTION: $task_description

RECENT COMMENTS (most recent first):
$comments

Based on the task title, description, and comments above, provide a concise 1-2 sentence summary that tells you:
1. What is the current status of this task?
2. What should you focus on or do next?

Focus on actionable information that helps you understand where things stand and what your next steps should be."
    
    # Generate AI summary
    local ai_response=$(echo "$prompt" | claude --model "$CLAUDE_MODEL" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$ai_response" ]; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Clean up response and cache it
    local clean_response=$(echo "$ai_response" | sed 's/^[ \t]*//;s/[ \t]*$//' | head -3 | tr '\n' ' ' | sed 's/  */ /g')
    echo "$clean_response" > "$cache_file"
    echo "$clean_response"
}

# Function to generate long AI summary with sections
generate_long_summary() {
    local task_data="$1"
    local task_id="$2"
    local last_updated="$3"
    local debug_mode="${4:-false}"
    
    if ! check_claude_available; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Check cache first
    local cache_key="ai_long_${task_id}_${last_updated}"
    local cache_file=$(get_cache_file "$cache_key")
    
    if [ -f "$cache_file" ]; then
        cat "$cache_file"
        return 0
    fi
    
    # Extract task and comment information for AI
    local task_name=$(echo "$task_data" | jq -r '.task.name // "Unknown Task"')
    local task_description=$(echo "$task_data" | jq -r '.task.description // ""' | sed 's/<[^>]*>//g' | sed 's/|[[:space:]]*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    local priority=$(echo "$task_data" | jq -r '.task.priority // "Normal"')
    local due_date=$(echo "$task_data" | jq -r '.task.dueDate // "Not set"')
    local comments=$(echo "$task_data" | jq -r '.comments[]? | "- " + (.body // "")' | head -5)
    local comment_count=$(echo "$task_data" | jq '.comments | length')
    
    # Check if task is empty (no description and no comments)
    if [ -z "$task_description" ] || [ "$task_description" = "null" ] || [ "$task_description" = "" ]; then
        if [ "$comment_count" -eq 0 ] || [ -z "$comments" ]; then
            local empty_summary="Empty task - no description or comments available"
            echo "$empty_summary" > "$cache_file"
            echo "$empty_summary"
            return 0
        fi
    fi
    
    # Debug output if requested
    if [ "$debug_mode" = "true" ]; then
        echo "=== DEBUG: Long Summary Data ===" >&2
        echo "Task Name: $task_name" >&2
        echo "Task Description: $task_description" >&2
        echo "Priority: $priority" >&2
        echo "Due Date: $due_date" >&2
        echo "Comments Count: $(echo "$task_data" | jq '.comments | length')" >&2
        echo "Comments:" >&2
        echo "$comments" >&2
        echo "=== END DEBUG ===" >&2
    fi
    
    # Build AI prompt with comprehensive context
    local prompt="You are analyzing a Teamwork task assigned to you. Carefully examine the task title, description, and recent comments to provide a comprehensive analysis of the current situation and what you need to do.

TASK TITLE: $task_name

PRIORITY: $priority

DUE DATE: $due_date

TASK DESCRIPTION: $task_description

RECENT COMMENTS (most recent first):
$comments

Analyze the task title, description, and comments above to understand:
- What work has been done so far?
- What is the current status/progress?
- What blockers or issues exist?
- What should you do next?

Format your response exactly as:

AI Summary: [2-3 sentences about the current status and progress based on analyzing the title, description, and comments. Focus on what you need to know about where things stand.]

Next Steps:
- [specific action you should take based on the task context]
- [another actionable step if applicable]
- [additional steps as needed to move forward]

Prioritize actionable insights that help you understand your current responsibilities and next actions for this specific task."
    
    # Generate AI summary
    local ai_response=$(echo "$prompt" | claude --model "$CLAUDE_MODEL" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$ai_response" ]; then
        echo "AI summary unavailable"
        return 1
    fi
    
    # Cache and return response
    echo "$ai_response" > "$cache_file"
    echo "$ai_response"
}

# Load environment variables from .env file in script directory or user's home
if [ -f "$SCRIPT_DIR/.env" ]; then
    export $(grep -v '^#' "$SCRIPT_DIR/.env" | xargs)
elif [ -f "$HOME/.tw.env" ]; then
    export $(grep -v '^#' "$HOME/.tw.env" | xargs)
else
    echo "Error: .env file not found."
    echo "Create either:"
    echo "  - $SCRIPT_DIR/.env (local to script)"
    echo "  - $HOME/.tw.env (global config)"
    echo ""
    echo "Use $SCRIPT_DIR/.env.example as template"
    exit 1
fi

# Check required environment variables
if [ -z "$TEAMWORK_URL" ] || [ -z "$API_KEY" ] || [ -z "$PASSWORD" ] || [ -z "$USER_ID" ]; then
    echo "Error: Missing required environment variables. Check your .env file."
    exit 1
fi

# Set default Claude model if not specified
if [ -z "$CLAUDE_MODEL" ]; then
    CLAUDE_MODEL="claude-3-5-sonnet-20241022"
fi

# Welcome message removed per user request

# Function to get auth header (consolidates duplicated auth header creation)
get_auth_header() {
    echo "Authorization: Basic $(echo -n "$API_KEY:$PASSWORD" | base64)"
}

# Function to validate priority filter
validate_priority() {
    local priority="$1"
    case "$priority" in
        high|medium|low|normal) return 0 ;;
        *) echo "Error: Invalid priority '$priority'. Use: high, medium, low, normal" >&2; return 1 ;;
    esac
}

# Function to validate order filter
validate_order() {
    local order="$1"
    case "$order" in
        priority|lastupdated|updated|duedate|due|start|startdate) return 0 ;;
        *) echo "Error: Invalid order '$order'. Use: priority, lastupdated, duedate, start" >&2; return 1 ;;
    esac
}

# Function to fetch all projects user is assigned to
fetch_assigned_projects() {
    local cache_key="projects_${USER_ID}"
    
    # Try to load from cache first
    local cache_file=$(get_cache_file "$cache_key")
    if is_cache_valid "$cache_file"; then
        echo "Loading projects from cache..." >&2
        cat "$cache_file"
        return 0
    fi
    
    local auth_header=$(get_auth_header)
    
    echo "Finding projects you are assigned to..." >&2
    
    # Fetch projects where user is assigned using the projects endpoint
    local response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/projects.json?userId=$USER_ID&pageSize=200")
    
    if [ $? -ne 0 ]; then
        echo "Error: Failed to fetch projects from Teamwork API" >&2
        exit 1
    fi
    
    # Check if response contains error
    local error=$(echo "$response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "API Error: $error" >&2
        exit 1
    fi
    
    # Extract projects and format them, add ALL PROJECTS option
    local formatted_projects=$(echo "$response" | jq '
        [.projects[] | {id: .id, name: .name}] + [{"id": "ALL", "name": "ALL PROJECTS"}]
    ')
    
    # Save to cache
    save_to_cache "$cache_key" "$formatted_projects"
    
    echo "$formatted_projects"
}

# Function for project selection wizard with arrow key navigation
project_wizard() {
    
    local projects_json=$(fetch_assigned_projects)
    
    # Debug: check what we got
    if [ -z "$projects_json" ]; then
        echo "Error: No projects data received"
        exit 1
    fi
    
    local project_count=$(echo "$projects_json" | jq 'length' 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$project_count" ]; then
        echo "Error: Invalid JSON data received"
        echo "Debug data: $projects_json"
        exit 1
    fi
    
    if [ "$project_count" -eq 0 ]; then
        echo "No projects found."
        exit 1
    fi
    
    local selected=0
    local key
    
    # Function to display projects list in clean format
    display_projects() {
        # Move cursor to top and clear screen below
        printf "\033[H\033[J"
        
        printf "\033[1mSELECT PROJECT\033[0m\n"
        printf "Use ↑/↓ arrow keys to navigate, Enter to select, q to quit\n"
        printf "\n"
        
        for i in $(seq 0 $((project_count - 1))); do
            local project_id=$(echo "$projects_json" | jq -r ".[$i].id")
            local project_name=$(echo "$projects_json" | jq -r ".[$i].name")
            
            if [ $i -eq $selected ]; then
                if [ "$project_id" = "ALL" ]; then
                    printf "▶ \033[1m%s\033[0m\n" "$project_name"
                else
                    printf "▶ \033[1m%s\033[0m \033[90m(ID: %s)\033[0m\n" "$project_name" "$project_id"
                fi
            else
                if [ "$project_id" = "ALL" ]; then
                    printf "  %s\n" "$project_name"
                else
                    printf "  %s \033[90m(ID: %s)\033[0m\n" "$project_name" "$project_id"
                fi
            fi
        done
    }
    
    display_projects
    
    while true; do
        read -rsn1 key
        case "$key" in
            $'\x1b')  # ESC sequence
                read -rsn2 key
                case "$key" in
                    '[A')  # Up arrow
                        selected=$((selected - 1))
                        if [ $selected -lt 0 ]; then
                            selected=$((project_count - 1))
                        fi
                        display_projects
                        ;;
                    '[B')  # Down arrow
                        selected=$((selected + 1))
                        if [ $selected -ge $project_count ]; then
                            selected=0
                        fi
                        display_projects
                        ;;
                esac
                ;;
            '')  # Enter key
                local selected_project_id=$(echo "$projects_json" | jq -r ".[$selected].id")
                echo
                echo "Selected project: $(echo "$projects_json" | jq -r ".[$selected].name")"
                
                # Store selected project in a temp file for future use
                echo "$selected_project_id" > /tmp/.tw_selected_project
                exit 0
                ;;
            'q'|'Q')
                echo
                echo "Cancelled."
                exit 0
                ;;
        esac
    done
}

# Function to select project if multiple exist
select_project() {
    # Check if there's a stored project selection
    if [ -f "/tmp/.tw_selected_project" ]; then
        local stored_project=$(cat /tmp/.tw_selected_project)
        if [ -n "$stored_project" ]; then
            echo "$stored_project"
            return
        fi
    fi
    
    # If no stored project, return empty and let calling function handle it
    echo ""
    return 1
}

# Function to format date from ISO to DD-MM-YYYY
format_date() {
    local iso_date="$1"
    if [ -n "$iso_date" ] && [ "$iso_date" != "null" ]; then
        date -j -f "%Y-%m-%dT%H:%M:%SZ" "$iso_date" "+%d-%m-%Y" 2>/dev/null || echo "No due date"
    else
        echo "No due date"
    fi
}

# Function to format markdown bold text for terminal
format_markdown() {
    local text="$1"
    # Convert **text** to bold using ANSI escape codes
    echo "$text" | sed 's/\*\*\([^*]*\)\*\*/\x1b[1m\1\x1b[0m/g'
}

# Function to format text with colors and bold  
format_priority() {
    local priority="$1"
    case "$priority" in
        "HIGH") 
            # White "Priority:" and bright red (not bold) "HIGH"
            printf '\033[37mPriority: \033[91mHIGH\033[0m'
            ;;
        "MEDIUM")
            # White "Priority:" and yellow "MEDIUM"
            printf '\033[37mPriority: \033[93mMEDIUM\033[0m'
            ;;
        "LOW")
            # White "Priority:" and blue "LOW"
            printf '\033[37mPriority: \033[34mLOW\033[0m'
            ;;
        *) 
            # White "Priority:" and normal color for value
            printf '\033[37mPriority: \033[0m%s' "$priority"
            ;;
    esac
}

# Function to format dates (check if overdue)
format_due_date() {
    local due_date="$1"
    local formatted_date="$2"
    
    if [ -n "$due_date" ] && [ "$due_date" != "null" ] && [ "$due_date" != "No due date" ]; then
        local today=$(date "+%Y-%m-%d")
        local due_date_only=$(echo "$due_date" | sed 's/T.*//')
        
        if [ "$due_date_only" \< "$today" ]; then
            # Overdue - bright red color
            printf '\033[91m!!! Due: %s !!!\033[0m' "$formatted_date"
        else
            echo "Due: $formatted_date"
        fi
    else
        echo "Due: $formatted_date"
    fi
}

# Function to build status indicators
build_status_indicators() {
    local task_id="$1"
    local updated_at="$2"
    local created_at="$3"
    local display_timezone="${4:-UTC}"
    
    local status_indicators=""
    if [ -n "$task_id" ] && [ -n "$updated_at" ]; then
        if is_task_actioned "$task_id" "$updated_at"; then
            status_indicators="$(format_actioned_status)"
        fi
    fi
    
    echo "$status_indicators"
}

# Function to format task titles in bold without status indicators
format_task_title() {
    local title="$1"
    local task_id="$2"
    local level="${3:-0}"  # Task level for indentation (0 = top level)
    
    # Add indentation for subtasks
    local indent=""
    if [ "$level" -gt 0 ]; then
        # Add "└─ " for subtasks
        indent="└─ "
        # Add additional spaces for deeper levels
        for ((i=1; i<level; i++)); do
            indent="   $indent"
        done
    fi
    
    # Format title with ID and indentation
    local id_suffix=""
    if [ -n "$task_id" ]; then
        id_suffix=" \033[90m#$task_id\033[0m"
    fi
    
    echo -n "${indent}$(printf '\033[1m%s\033[0m' "$title")${id_suffix}"
}

# Function to format actioned status in green and bold
format_actioned_status() {
    printf '\033[32m\033[1m✔ Actioned\033[0m'
}



# Function to strip ANSI color codes for width calculation
strip_colors() {
    local text="$1"
    # Strip ANSI escape sequences in both \x1b and \033 formats
    echo "$text" | sed -e 's/\x1b\[[0-9;]*[a-zA-Z]//g' -e 's/\\033\[[0-9;]*[a-zA-Z]//g' -e 's/\[[0-9;]*m//g'
}

# Function to pad colored text to specific width
pad_colored_text() {
    local text="$1"
    local width="$2"
    local stripped=$(strip_colors "$text")
    # Use wc -m to count characters, not bytes, and subtract 1 for newline
    local char_count=$(echo -n "$stripped" | wc -m)
    local padding=$((width - char_count))
    
    if [ $padding -gt 0 ]; then
        printf "%s%*s" "$text" $padding ""
    else
        echo "$text"
    fi
}

# Function to format bullet points with proper hanging indent
format_bullet_point() {
    local text="$1"
    local first_indent="$2"     # e.g., "     • "
    local hanging_indent="$3"   # e.g., "       "
    local width="${4:-75}"      # Default wrap width
    
    # Use fold to wrap the text, then add proper indentation
    echo "$text" | fold -s -w $((width - ${#hanging_indent})) | {
        local first_line=true
        while IFS= read -r line; do
            if [ -n "$line" ]; then
                if [ "$first_line" = true ]; then
                    printf "%s%s\n" "$first_indent" "$line"
                    first_line=false
                else
                    printf "%s%s\n" "$hanging_indent" "$line"
                fi
            fi
        done
    }
}



# Function to display single task in clean format (matching tasks format)
# This is a wrapper that ensures single task view shows full comments
format_clean_single_task_display() {
    local task_name="$1"
    local task_id="$2"
    local priority="$3"
    local formatted_due="$4"
    local formatted_start="$5"  # Not used but kept for compatibility
    local description="$6"
    local task_url="$7"
    local formatted_tags="$8"   # Not used but kept for compatibility
    local ai_summary="$9"
    local comments_data="${10}"
    local comments_mode="${11}" # Ignored - always uses "full" for single task
    
    # Use the same format as task list, but force full comments display
    format_clean_task_display "$task_name" "$task_id" "$priority" "$formatted_due" "$description" "$ai_summary" "$comments_data" "full" "$task_url"
}

# Function to display tasks in clean format
# This is the SINGLE SOURCE OF TRUTH for task display formatting
# Used by both 'tw tasks' and 'tw task' commands
# Any changes to task display should be made here
format_clean_task_display() {
    local task_name="$1"
    local task_id="$2"
    local priority="$3"
    local formatted_due="$4"
    local description="$5"
    local ai_summary="$6"
    local comments_data="$7"
    local comments_mode="$8"  # "full" for single task, number/empty for task list
    local task_url="$9"
    
    # Format priority display
    local priority_display="$priority"
    case "$priority" in
        "high") priority_display="HIGH" ;;
        "medium") priority_display="MEDIUM" ;;
        "low") priority_display="LOW" ;;
        *) priority_display="NORMAL" ;;
    esac
    
    # Format priority with bold colors for better visibility
    local priority_colored=""
    case "$priority" in
        "high") priority_colored="\033[91m\033[1m[HIGH]\033[0m" ;;
        "medium") priority_colored="\033[93m\033[1m[MEDIUM]\033[0m" ;;
        "low") priority_colored="\033[92m\033[1m[LOW]\033[0m" ;;
        *) priority_colored="\033[37m[NORMAL]\033[0m" ;;
    esac
    
    # Format due date with overdue color
    local due_colored="$formatted_due"
    if [[ "$formatted_due" == *"OVERDUE"* ]]; then
        due_colored="\033[91m$formatted_due\033[0m"
    fi
    
    # Display task ID in grey above the title
    printf "  \033[90m#%s\033[0m\n" "$task_id"
    
    # Calculate space needed for right info (due date and priority)
    local right_info_clean="Due: $formatted_due  [$priority_display]"
    local right_len=${#right_info_clean}
    local available_title_space=$((78 - right_len - 2))  # -2 for spacing
    
    # Wrap title if necessary
    local display_name="$(echo "$task_name" | tr '[:lower:]' '[:upper:]')"
    if [ ${#display_name} -gt $available_title_space ]; then
        # Truncate title to fit, ensuring we don't break in middle of word
        local truncated_name="${display_name:0:$((available_title_space-3))}"
        # Find last space to avoid breaking words
        local last_space_pos="${truncated_name% *}"
        if [ ${#last_space_pos} -lt $((available_title_space-10)) ]; then
            # If breaking at last space makes it too short, just truncate
            display_name="${truncated_name}..."
        else
            display_name="${last_space_pos}..."
        fi
    fi
    
    # Display title with due date right-aligned on same line
    local title_len=${#display_name}
    local padding=$((78 - title_len - right_len))
    
    printf "  \033[1m%s\033[0m" "$display_name"
    printf "%*s" $padding ""
    echo -e "Due: $due_colored  $priority_colored"
    printf "\n"
    
    # Description section
    if [ -n "$description" ] && [ "$description" != "null" ]; then
        printf "  \033[1mDescription\033[0m\n"
        echo "$description" | fold -s -w 75 | while IFS= read -r line; do
            if [ -n "$line" ]; then
                printf "  %s\n" "$line"
            fi
        done
        printf "\n"
    fi
    
    # AI Summary section
    if [ -n "$ai_summary" ]; then
        # Extract just the summary part (before "Next Steps:")
        local summary_only=$(echo "$ai_summary" | sed -n '1,/^Next Steps:/p' | sed '/^Next Steps:/d' | sed 's/^AI Summary: //')
        # Extract next steps first to determine if we should show the box
        local next_steps=$(echo "$ai_summary" | sed -n '/Next Steps:/,$p' | sed '1d' | sed '/^$/d')
        
        if [ -n "$summary_only" ] || [ -n "$next_steps" ]; then
            printf "  \033[1m\033[34mAI Summary\033[0m\n"
            
            # Display summary content if present
            if [ -n "$summary_only" ]; then
                echo "$summary_only" | fold -s -w 75 | while IFS= read -r line; do
                    if [ -n "$line" ]; then
                        printf "  %s\n" "$line"
                    fi
                done
            fi
            
            # Display next steps if present
            if [ -n "$next_steps" ]; then
                # Add separator line if we had summary content
                if [ -n "$summary_only" ]; then
                    printf "\n"
                fi
                printf "  \033[1m\033[34mNext steps\033[0m\n"
                echo "$next_steps" | while IFS= read -r line; do
                    if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*(.*) ]]; then
                        local bullet_text="${BASH_REMATCH[1]}"
                        # Wrap bullet text manually to maintain left border
                        echo "$bullet_text" | fold -s -w 71 | {
                            local first_line=true
                            while IFS= read -r wrapped_line; do
                                if [ -n "$wrapped_line" ]; then
                                    if [ "$first_line" = true ]; then
                                        printf "  • %s\n" "$wrapped_line"
                                        first_line=false
                                    else
                                        printf "    %s\n" "$wrapped_line"
                                    fi
                                fi
                            done
                        }
                    elif [ -n "$line" ]; then
                        printf "  %s\n" "$line"
                    fi
                done
            fi
            
            # Add spacing after AI summary, adjusted for comments
            if [ -n "$comments_data" ] && [ "$comments_mode" != "" ]; then
                printf "\n"
            else
                printf "\n\n"
            fi
        fi
    fi
    
    # Comments section
    if [ -n "$comments_data" ] && [ "$comments_mode" != "" ]; then
        format_comments_display "$comments_data" "false"
    fi
    
    # Add minimal dotted line separator between tasks for better scanability
    printf "\n  "
    printf '·%.0s' {1..76}  # 76 dots to align with 78-char width (minus 2 for indentation)
    printf "\n\n"
}

# Function to get user name from ID
get_user_name() {
    local user_id="$1"
    local auth_header=$(get_auth_header)
    local response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/people/$user_id.json" 2>/dev/null)
    
    if [ $? -eq 0 ] && [ -n "$response" ]; then
        local first_name=$(echo "$response" | jq -r '.person.firstName // empty' 2>/dev/null)
        local last_name=$(echo "$response" | jq -r '.person.lastName // empty' 2>/dev/null)
        if [ -n "$first_name" ] && [ -n "$last_name" ]; then
            echo "$first_name $last_name"
        else
            echo "User $user_id"
        fi
    else
        echo "User $user_id"
    fi
}

# Function to fetch task comments for clean display
fetch_task_comments_for_display() {
    local task_id="$1"
    local limit="$2"
    
    local auth_header=$(get_auth_header)
    local response=$(curl -s -H "$auth_header" \
        "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/comments.json?pageSize=50" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$response" ]; then
        echo "[]"
        return
    fi
    
    # Parse comments with user IDs for later name resolution
    echo "$response" | jq --arg limit "$limit" -r '
        [.comments[]? | select(.body and .body != "") | {
            body: (.body | gsub("<[^>]*>"; "") | gsub("\\r\\n|\\n"; " ")),
            bodyFull: (.body | gsub("<[^>]*>"; "") | gsub("\\r\\n"; "\n") | gsub("\\n\\n+"; "\n\n")),
            userId: .postedByUserId,
            date: (.postedDateTime | split("T")[0] | split("-") | [.[1], .[2]] | join("/"))
        }] | sort_by(.date) | reverse | .[0:($limit | tonumber)]
    ' 2>/dev/null || echo "[]"
}

# Function to format comments for display
format_comments_display() {
    local comments_data="$1"
    local display_mode="$2"  # "false" for task list, "true" for single task (legacy), "full" for full comments with task list format
    
    if [ -z "$comments_data" ] || [ "$comments_data" = "[]" ]; then
        return
    fi
    
    local comment_count=$(echo "$comments_data" | jq '. | length')
    if [ "$comment_count" -eq 0 ]; then
        return
    fi
    
    printf "  \033[1mRecent comments (%s)\033[0m\n" "$comment_count"
    
    # Process each comment
    echo "$comments_data" | jq -c '.[]' | while read -r comment; do
        local user_id=$(echo "$comment" | jq -r '.userId')
        local date=$(echo "$comment" | jq -r '.date')
        local user_name=$(get_user_name "$user_id")
        local body=$(echo "$comment" | jq -r '.body')
        
        # Format the comment with proper line length considering prefix
        local prefix="  $date  $user_name: "
        local prefix_len=${#prefix}
        local max_comment_width=$((75 - prefix_len))
        
        if [ "$display_mode" = "full" ]; then
            # Full comment text for single task view (but using task list format)
            if [ ${#body} -le $max_comment_width ]; then
                # Comment fits on one line
                printf "%s%s\n" "$prefix" "$body"
            else
                # Show full comment with wrapping
                printf "%s" "$prefix"
                local first_line=true
                echo "$body" | fold -s -w $max_comment_width | while IFS= read -r line; do
                    if [ -n "$line" ]; then
                        if [ "$first_line" = true ]; then
                            printf "%s\n" "$line"
                            first_line=false
                        else
                            printf "%*s%s\n" $prefix_len "" "$line"
                        fi
                    fi
                done
            fi
        elif [ "$display_mode" = "true" ]; then
            # Legacy single task view - keep for backwards compatibility
            local full_body=$(echo "$comment" | jq -r '.bodyFull')
            printf "  \033[1m%s - %s\033[0m\n" "$date" "$user_name"
            echo "$full_body" | fold -s -w 71 | while IFS= read -r line; do
                if [ -n "$line" ]; then
                    printf "  %s\n" "$line"
                fi
            done
            printf "\n"
        else
            # Truncated comment for task list view with proper wrapping
            if [ ${#body} -le $max_comment_width ]; then
                # Comment fits on one line
                printf "%s%s\n" "$prefix" "$body"
            else
                # Wrap the comment properly
                local first_line="${body:0:$max_comment_width}"
                # Try to break at a word boundary
                if [[ "$first_line" != "$body" ]] && [[ "${body:$max_comment_width:1}" != " " ]]; then
                    local last_space_pos="${first_line% *}"
                    if [ ${#last_space_pos} -gt $((max_comment_width * 2 / 3)) ]; then
                        first_line="$last_space_pos..."
                    else
                        first_line="${first_line}..."
                    fi
                fi
                printf "%s%s\n" "$prefix" "$first_line"
            fi
        fi
    done
    printf "\n"
}

# Function to fetch tags for the project and create a lookup map
fetch_tags() {
    local project_id="$1"
    local cache_key="tags_global"
    
    # Try to load from cache first
    local cache_file=$(get_cache_file "$cache_key")
    if is_cache_valid "$cache_file"; then
        echo "Loading tags from cache..." >&2
        cat "$cache_file"
        return 0
    fi
    
    local auth_header=$(get_auth_header)
    
    # Fetch tags - the API seems to be global but we can filter if needed
    local response=$(curl -s -H "$auth_header" \
        "$TEAMWORK_URL/projects/api/v3/tags.json?pageSize=500")
    
    if [ $? -ne 0 ]; then
        echo "{}" # Return empty object on error
        return 1
    fi
    
    # Check if response contains error
    local error=$(echo "$response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        echo "{}" # Return empty object on error
        return 1
    fi
    
    # Convert tags array to lookup object {tagId: {name: "tag name", color: "color"}}
    local tags_lookup=$(echo "$response" | jq -r '
        .tags | map({(.id | tostring): {name: .name, color: .color}}) | add // {}
    ')
    
    # Save to cache
    save_to_cache "$cache_key" "$tags_lookup"
    
    echo "$tags_lookup"
}

# Function to format tags for display
format_tags() {
    local tag_ids="$1"
    local tags_lookup="$2"
    
    if [ -z "$tag_ids" ] || [ "$tag_ids" = "null" ] || [ "$tag_ids" = "[]" ]; then
        echo ""
        return
    fi
    
    # Parse tag IDs and format them
    local tag_names=$(echo "$tag_ids" | jq -r --argjson lookup "$tags_lookup" '
        if type == "array" then
            map(tostring) | map($lookup[.].name // ("Tag " + .)) | join(", ")
        else
            empty
        end
    ' 2>/dev/null)
    
    if [ -n "$tag_names" ] && [ "$tag_names" != "null" ]; then
        echo "$tag_names"
    else
        echo ""
    fi
}

# Function to check if a task matches priority filter
matches_priority_filter() {
    local task_priority="$1"
    local filter="$2"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    # Convert to lowercase for case-insensitive comparison
    local task_priority_lower=$(echo "$task_priority" | tr '[:upper:]' '[:lower:]')
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    
    case "$filter_lower" in
        "high") [ "$task_priority_lower" = "high" ] ;;
        "medium") [ "$task_priority_lower" = "medium" ] ;;
        "low") [ "$task_priority_lower" = "low" ] ;;
        "normal") [ "$task_priority_lower" = "normal" ] || [ -z "$task_priority" ] ;;
        *) return 1 ;;
    esac
}

# Function to check if a task matches due date filter
matches_due_filter() {
    local task_due_date="$1"
    local filter="$2"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    local today=$(date "+%Y-%m-%d")
    
    case "$filter_lower" in
        "today")
            [ "$(echo "$task_due_date" | sed 's/T.*//')" = "$today" ]
            ;;
        "overdue")
            if [ -n "$task_due_date" ] && [ "$task_due_date" != "null" ]; then
                local due_date_only=$(echo "$task_due_date" | sed 's/T.*//')
                [ "$due_date_only" \< "$today" ]
            else
                return 1
            fi
            ;;
        */*/* | *-*-*)
            # Date format - try to parse various formats
            local input_date=""
            if [[ "$filter" =~ ^[0-9]{1,2}/[0-9]{1,2}/[0-9]{2,4}$ ]]; then
                # DD/MM/YY or DD/MM/YYYY format
                input_date=$(echo "$filter" | awk -F'/' '{
                    year = $3
                    if (length(year) == 2) year = "20" year
                    printf "%04d-%02d-%02d", year, $2, $1
                }')
            elif [[ "$filter" =~ ^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$ ]]; then
                # YYYY-MM-DD format
                input_date="$filter"
            else
                return 1
            fi
            
            if [ -n "$task_due_date" ] && [ "$task_due_date" != "null" ]; then
                local due_date_only=$(echo "$task_due_date" | sed 's/T.*//')
                [ "$due_date_only" = "$input_date" ]
            else
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to check if a task matches start date filter
matches_start_filter() {
    local task_start_date="$1"
    local filter="$2"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    local today=$(date "+%Y-%m-%d")
    
    case "$filter_lower" in
        "today")
            [ "$(echo "$task_start_date" | sed 's/T.*//')" = "$today" ]
            ;;
        */*/* | *-*-*)
            # Date format - same logic as due date
            local input_date=""
            if [[ "$filter" =~ ^[0-9]{1,2}/[0-9]{1,2}/[0-9]{2,4}$ ]]; then
                input_date=$(echo "$filter" | awk -F'/' '{
                    year = $3
                    if (length(year) == 2) year = "20" year
                    printf "%04d-%02d-%02d", year, $2, $1
                }')
            elif [[ "$filter" =~ ^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$ ]]; then
                input_date="$filter"
            else
                return 1
            fi
            
            if [ -n "$task_start_date" ] && [ "$task_start_date" != "null" ]; then
                local start_date_only=$(echo "$task_start_date" | sed 's/T.*//')
                [ "$start_date_only" = "$input_date" ]
            else
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to check if a task matches tags filter
matches_tags_filter() {
    local task_tag_ids="$1"
    local tags_lookup="$2"
    local filter="$3"
    
    if [ -z "$filter" ]; then
        return 0  # No filter, matches all
    fi
    
    if [ -z "$task_tag_ids" ] || [ "$task_tag_ids" = "null" ] || [ "$task_tag_ids" = "[]" ]; then
        return 1  # Task has no tags
    fi
    
    local filter_lower=$(echo "$filter" | tr '[:upper:]' '[:lower:]')
    
    # Get tag names for this task
    local task_tag_names=$(echo "$task_tag_ids" | jq -r --argjson lookup "$tags_lookup" '
        if type == "array" then
            map(tostring) | map($lookup[.].name // "") | join("|")
        else
            ""
        end
    ' 2>/dev/null)
    
    if [ -n "$task_tag_names" ]; then
        local task_tag_names_lower=$(echo "$task_tag_names" | tr '[:upper:]' '[:lower:]')
        echo "$task_tag_names_lower" | grep -q "$filter_lower"
    else
        return 1
    fi
}

# Function to fetch subtasks - simplified for better performance
fetch_subtasks_simple() {
    local task_ids="$1"
    local auth_header="$2"
    local user_id="$3"
    local max_depth="${4:-3}"
    
    # Create temp file for results
    local temp_file=$(mktemp)
    local current_ids="$task_ids"
    local level=1
    
    # Fetch subtasks level by level
    while [ -n "$current_ids" ] && [ "$level" -le "$max_depth" ]; do
        local next_ids=""
        
        # Fetch subtasks in parallel for current level
        local pids=()
        local temp_dir=$(mktemp -d)
        local batch_counter=0
        
        for task_id in $current_ids; do
            if [ -n "$task_id" ]; then
                {
                    # Fetch subtasks for this task in parallel
                    local response=$(curl -s -H "$auth_header" \
                        "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/subtasks.json?pageSize=100" 2>/dev/null)
                    
                    if [ $? -eq 0 ] && [ -n "$response" ]; then
                        # Extract subtasks assigned to user - filter out problematic descriptions
                        echo "$response" | jq -c --arg user_id "$user_id" --arg level "$level" '
                            .tasks[]?
                            | select(.assigneeUserIds[]? == ($user_id | tonumber))
                            | select(.status != "completed" and .status != "complete" and .status != "done" and .progress != 100)
                            | select(.status // "unknown" | test("^(completed|complete|done)$") | not)
                            | {
                                id: .id,
                                name: .name,
                                priority: .priority,
                                dueDate: .dueDate,
                                startDate: .startDate,
                                description: (.description // "" | gsub("\\\\&"; "&") | gsub("\\n"; " | ") | gsub("\\r"; "") | gsub("\\\\"; "")),
                                projectId: .projectId,
                                tagIds: .tagIds,
                                updatedAt: .updatedAt,
                                createdAt: .createdAt,
                                parentTaskId: .parentTaskId,
                                level: ($level | tonumber)
                            }' > "$temp_dir/subtasks_${task_id}.json" 2>/dev/null
                    fi
                } &
                pids+=($!)
                ((batch_counter++))
                
                # Limit concurrent processes to avoid overwhelming the API
                if [ $batch_counter -ge 8 ]; then
                    # Wait for this batch to complete
                    for pid in "${pids[@]}"; do
                        wait $pid
                    done
                    pids=()
                    batch_counter=0
                fi
            fi
        done
        
        # Wait for remaining processes
        for pid in "${pids[@]}"; do
            wait $pid
        done
        
        # Collect results and prepare next level
        for result_file in "$temp_dir"/subtasks_*.json; do
            if [ -f "$result_file" ] && [ -s "$result_file" ]; then
                # Add to main results
                cat "$result_file" >> "$temp_file"
                
                # Collect IDs for next level
                local new_ids=$(cat "$result_file" | jq -r '.id // empty' 2>/dev/null | tr '\n' ' ')
                next_ids="$next_ids $new_ids"
            fi
        done
        
        # Clean up temporary files
        rm -rf "$temp_dir"
        
        # Move to next level
        current_ids="$next_ids"
        level=$((level + 1))
    done
    
    # Output all results
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        cat "$temp_file"
    fi
    
    # Cleanup
    rm -f "$temp_file"
}

# Function to get tasks
get_tasks() {
    # Filter parameters
    local priority_filter=""
    local due_filter=""
    local start_filter=""
    local tags_filter=""
    local summary_mode="long"
    local debug_mode="false"
    local display_timezone="UTC"  # Default to UTC
    local order_by="duedate"  # Default ordering
    local include_subtasks="true"  # Default to including subtasks
    local max_subtask_depth="${SUBTASK_MAX_DEPTH:-3}"  # Max depth from env or default to 3
    local max_subtasks_per_parent="${SUBTASK_MAX_PER_PARENT:-50}"  # Max subtasks per parent
    local comments_mode="3"  # Comments display mode - default to showing 3 comments
    local comments_limit="3"  # Number of comments to show (when comments_mode is set)
    local quick_mode=""  # Quick/simple output mode flag
    
    # Parse flags
    shift # Remove 'tasks' from arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quick)
                quick_mode="true"
                shift
                ;;
            --priority=*)
                priority_filter="${1#*=}"
                if [ -n "$priority_filter" ] && ! validate_priority "$priority_filter"; then
                    exit 1
                fi
                shift
                ;;
            --due=*)
                due_filter="${1#*=}"
                shift
                ;;
            --start=*)
                start_filter="${1#*=}"
                shift
                ;;
            --tags=*)
                tags_filter="${1#*=}"
                shift
                ;;
            --no-summary)
                summary_mode=""
                shift
                ;;
            --order=*)
                order_by="${1#*=}"
                if [ -n "$order_by" ] && ! validate_order "$order_by"; then
                    exit 1
                fi
                shift
                ;;
            --debug)
                debug_mode="true"
                shift
                ;;
            --timezone=*)
                display_timezone="${1#*=}"
                shift
                ;;
            --no-subtasks)
                include_subtasks="false"
                shift
                ;;
            --subtask-depth=*)
                max_subtask_depth="${1#*=}"
                shift
                ;;
            --comments=*)
                comments_mode="${1#*=}"
                comments_limit="${1#*=}"
                shift
                ;;
            --comments)
                comments_mode="3"
                comments_limit="3"
                shift
                ;;
            --no-comments)
                comments_mode=""
                comments_limit=""
                shift
                ;;
            --help)
                echo "Use 'tw flags' to see available commands and options."
                return 0
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use 'tw tasks --help' for usage information."
                return 1
                ;;
        esac
    done
    
    local project_id=$(select_project)
    if [ $? -ne 0 ] || [ -z "$project_id" ]; then
        echo "No project selected. Please run 'tw' to select a project first."
        exit 1
    fi
    
    # Try to load from cache first
    local cache_key="tasks_${project_id}_${USER_ID}_with_tasklists"
    local cache_file=$(get_cache_file "$cache_key")
    local show_update_indicator=false
    
    if ! is_task_data_current "$cache_file" "$project_id"; then
        # Cache miss or data changed - fetch from API
        local auth_header=$(get_auth_header)
        
        if [ "$project_id" = "ALL" ]; then
            start_spinner "Project-ing all tasks from all projects..."
            
            # Fetch tasks from all projects using the tasks endpoint with user filter
            # Use field selection to reduce payload size and improve performance
            response=$(curl -s -H "$auth_header" \
                "$TEAMWORK_URL/projects/api/v3/tasks.json?assigneeUserIds=$USER_ID&pageSize=500&fields=id,name,priority,dueDate,startDate,description,projectId,tagIds,updatedAt,createdAt,parentTaskId,assigneeUserIds,status,progress")
            
            # Also fetch tasks from inbox/personal tasklists to catch tasks with projectId: null
            update_spinner "In-box-ing personal tasklists..."
            local inbox_response=$(curl -s -H "$auth_header" \
                "$TEAMWORK_URL/projects/api/v3/tasklists.json?pageSize=500&fields=id,name,projectId" 2>/dev/null)
            
            if [ $? -eq 0 ] && [ -n "$inbox_response" ]; then
                # Find inbox-like tasklists (by name pattern)
                local inbox_tasklists=$(echo "$inbox_response" | jq -r '.tasklists[]? | select(.name | test("inbox|personal|my|unassigned"; "i")) | .id' 2>/dev/null)
                
                if [ -n "$inbox_tasklists" ]; then
                    local inbox_tasks_json="[]"
                    local temp_file=$(mktemp)
                    echo "$inbox_tasks_json" > "$temp_file"
                    
                    for tasklist_id in $inbox_tasklists; do
                        if [ -n "$tasklist_id" ]; then
                            local tasklist_response=$(curl -s -H "$auth_header" \
                                "$TEAMWORK_URL/projects/api/v3/tasklists/$tasklist_id/tasks.json?assigneeUserIds=$USER_ID&fields=id,name,priority,dueDate,startDate,description,projectId,tagIds,updatedAt,createdAt,parentTaskId,assigneeUserIds,status,progress" 2>/dev/null)
                            
                            if [ $? -eq 0 ] && [ -n "$tasklist_response" ]; then
                                local tasks_from_list=$(echo "$tasklist_response" | jq '.tasks // []' 2>/dev/null)
                                if [ -n "$tasks_from_list" ] && [ "$tasks_from_list" != "null" ] && [ "$tasks_from_list" != "[]" ]; then
                                    local current_json=$(cat "$temp_file")
                                    echo "$current_json" "$tasks_from_list" | jq -s 'add' > "$temp_file" 2>/dev/null || echo "$current_json" > "$temp_file"
                                fi
                            fi
                        fi
                    done
                    
                    inbox_tasks_json=$(cat "$temp_file")
                    rm -f "$temp_file"
                    
                    # Merge inbox tasks with main response if we found any
                    if [ -n "$inbox_tasks_json" ] && [ "$inbox_tasks_json" != "[]" ]; then
                        local main_tasks=$(echo "$response" | jq '.tasks // []' 2>/dev/null)
                        local combined_tasks=$(echo "$main_tasks" "$inbox_tasks_json" | jq -s 'add | unique_by(.id)' 2>/dev/null)
                        if [ -n "$combined_tasks" ]; then
                            response=$(echo "$response" | jq --argjson tasks "$combined_tasks" '.tasks = $tasks' 2>/dev/null)
                        fi
                    fi
                fi
            fi
        else
            start_spinner "Task-ing you to wait while I fetch project $project_id..."
            
            # Fetch tasks from specific project with field selection for better performance
            response=$(curl -s -H "$auth_header" \
                "$TEAMWORK_URL/projects/api/v3/projects/$project_id/tasks.json?fields=id,name,priority,dueDate,startDate,description,projectId,tagIds,updatedAt,createdAt,parentTaskId,assigneeUserIds,status,progress")
            
        fi
        
        if [ $? -ne 0 ]; then
            echo "Error: Failed to fetch tasks from Teamwork API"
            exit 1
        fi
        
        # Check if response contains error
        local error=$(echo "$response" | jq -r '.error // empty')
        if [ -n "$error" ]; then
            echo "API Error: $error"
            exit 1
        fi
        
        # If fetching for a specific project, also fetch tasks from tasklists to catch missing tasks
        if [ "$project_id" != "ALL" ]; then
            update_spinner "List-ening for tasklists and their tasks..."
            
            # Fetch tasklists in the project with timeout protection
            local tasklists_response
            if ! tasklists_response=$(curl -s --max-time 20 -H "$auth_header" \
                "$TEAMWORK_URL/projects/api/v3/projects/$project_id/tasklists.json?pageSize=200" 2>/dev/null); then
                echo "Warning: Tasklist fetch timed out, proceeding with project tasks only"
            elif [ -n "$tasklists_response" ]; then
                local tasklists=$(echo "$tasklists_response" | jq -r '.tasklists[]?.id // empty' 2>/dev/null)
                
                if [ -n "$tasklists" ]; then
                    if [ "$debug_mode" = "true" ]; then
                        local tasklist_count=$(echo "$tasklists" | wc -l)
                        echo "DEBUG: Found $tasklist_count tasklists to fetch from" >&2
                    fi
                    
                    local tasklist_tasks_json="[]"
                    local processed=0
                    
                    # Fetch tasks from each tasklist with spinner
                    local total_tasklists=$(echo "$tasklists" | wc -l)
                    update_spinner "Check-listing $total_tasklists tasklists..."
                    
                    while IFS= read -r tasklist_id; do
                        if [ -n "$tasklist_id" ] && [ "$tasklist_id" != "null" ]; then
                            processed=$((processed + 1))
                            
                            # Add timeout and filter by assignee at API level
                            local tasklist_response
                            if tasklist_response=$(curl -s --max-time 15 -H "$auth_header" \
                                "$TEAMWORK_URL/projects/api/v3/tasklists/$tasklist_id/tasks.json?assigneeUserIds=$USER_ID&fields=id,name,priority,dueDate,startDate,description,projectId,tagIds,updatedAt,createdAt,parentTaskId,assigneeUserIds,status,progress&pageSize=500" 2>/dev/null); then
                                
                                local tasks_from_list=$(echo "$tasklist_response" | jq '.tasks // []' 2>/dev/null)
                                if [ -n "$tasks_from_list" ] && [ "$tasks_from_list" != "null" ] && [ "$tasks_from_list" != "[]" ]; then
                                    local task_count=$(echo "$tasks_from_list" | jq 'length' 2>/dev/null || echo "0")
                                    if [ "$task_count" -gt 0 ]; then
                                        tasklist_tasks_json=$(echo "$tasklist_tasks_json" "$tasks_from_list" | jq -s 'add' 2>/dev/null || echo "$tasklist_tasks_json")
                                        if [ "$debug_mode" = "true" ]; then
                                            # Stop spinner before debug output
                                            stop_spinner
                                            echo "DEBUG: Found $task_count tasks in tasklist $tasklist_id" >&2
                                            # Restart spinner
                                            start_spinner "Checking tasklists..."
                                        fi
                                    fi
                                fi
                            else
                                if [ "$debug_mode" = "true" ]; then
                                    # Stop spinner before debug output
                                    stop_spinner
                                    echo "DEBUG: Timeout fetching from tasklist $tasklist_id" >&2
                                    # Restart spinner
                                    start_spinner "Checking tasklists..."
                                fi
                            fi
                        fi
                    done <<< "$tasklists"
                    
                    stop_spinner
                    
                    # Combine regular project tasks with tasklist tasks, removing duplicates
                    if [ -n "$tasklist_tasks_json" ] && [ "$tasklist_tasks_json" != "[]" ]; then
                        local project_tasks=$(echo "$response" | jq '.tasks // []')
                        local combined_response
                        if combined_response=$(echo "$project_tasks" "$tasklist_tasks_json" | jq -s '{tasks: (.[0] + .[1]) | unique_by(.id)}' 2>/dev/null); then
                            response="$combined_response"
                            if [ "$debug_mode" = "true" ]; then
                                local original_count=$(echo "$project_tasks" | jq 'length' 2>/dev/null || echo "0")
                                local tasklist_task_count=$(echo "$tasklist_tasks_json" | jq 'length' 2>/dev/null || echo "0")
                                local final_count=$(echo "$combined_response" | jq '.tasks | length' 2>/dev/null || echo "0")
                                echo "DEBUG: Combined $original_count project tasks + $tasklist_task_count tasklist tasks = $final_count unique tasks" >&2
                            fi
                        fi
                    fi
                fi
            fi
        fi
        
        # Save to cache
        save_to_cache "$cache_key" "$response"
    else
        echo "Loading tasks from cache..."
        echo
        show_update_indicator=true
    fi

    # Fetch tags if needed (for display or filtering)
    local tags_lookup="{}"
    if [ -n "$tags_filter" ]; then
        tags_lookup=$(fetch_tags "$project_id")
    fi
    
    # Store tasks data for processing with dynamic sorting
    local sort_expression=""
    local order_description=""
    
    case "$order_by" in
        "priority")
            # Sort by priority: high=1, medium=2, normal/null=3, low=4
            sort_expression='sort_by(if .priority == "high" then 1 elif .priority == "medium" then 2 elif (.priority == "low") then 4 else 3 end)'
            order_description="priority order (high → medium → normal → low)"
            ;;
        "lastupdated"|"updated")
            sort_expression='sort_by(.updatedAt // "1900-01-01") | reverse'
            order_description="last updated (newest first)"
            ;;
        "duedate"|"due")
            sort_expression='sort_by(.dueDate // "9999-12-31")'
            order_description="due date order (overdue first)"
            ;;
        "start"|"startdate")
            sort_expression='sort_by(.startDate // "9999-12-31")'
            order_description="start date order"
            ;;
        *)
            # Default to due date
            sort_expression='sort_by(.dueDate // "9999-12-31")'
            order_description="due date order (overdue first)"
            ;;
    esac
    
    # Get initial tasks - output each as compact JSON with cleaned descriptions
    # Apply double-filtering to catch any stale cached completed tasks
    local initial_tasks=$(echo "$response" | jq -c --arg user_id "$USER_ID" '
        .tasks[]
        | select(.assigneeUserIds[]? == ($user_id | tonumber))
        | select(.status != "completed" and .status != "complete" and .status != "done" and .progress != 100)
        | select(.status // "unknown" | test("^(completed|complete|done)$") | not)  # Additional safety check
        | {
            id: .id,
            name: .name,
            priority: .priority,
            dueDate: .dueDate,
            startDate: .startDate,
            description: (.description // "" | gsub("\\\\&"; "&") | gsub("\\n"; " | ") | gsub("\\r"; "") | gsub("\\\\"; "")),
            projectId: .projectId,
            tagIds: .tagIds,
            updatedAt: .updatedAt,
            createdAt: .createdAt,
            parentTaskId: .parentTaskId,
            level: 0
        }
    ')
    
    # Fetch subtasks if enabled
    if [ "$include_subtasks" = "true" ]; then
        local auth_header=$(get_auth_header)
        
        if [ "$debug_mode" = "true" ]; then
            echo "DEBUG: Fetching subtasks is enabled" >&2
            echo "DEBUG: Initial tasks count: $(echo "$initial_tasks" | jq -s 'length')" >&2
        fi
        
        # Get task IDs from initial tasks
        local task_ids=$(echo "$initial_tasks" | jq -r '.id' | tr '\n' ' ')
        
        if [ "$debug_mode" = "true" ]; then
            echo "DEBUG: Fetching subtasks for tasks: $task_ids" >&2
            echo "DEBUG: Max depth: $max_subtask_depth, Max per parent: $max_subtasks_per_parent" >&2
        fi
        
        # Check if we have cached subtasks
        local subtask_cache_key="subtasks_${project_id}_${USER_ID}_depth${max_subtask_depth}"
        local subtask_cache_file=$(get_cache_file "$subtask_cache_key")
        local subtasks=""
        
        # Try to use cached subtasks if tasks haven't been updated
        if [ -f "$subtask_cache_file" ] && is_task_data_current "$subtask_cache_file" "$project_id"; then
            echo "Loading subtasks from cache..." >&2
            # Load cached subtasks - they should be valid compact JSON
            subtasks=$(cat "$subtask_cache_file")
            # Validate that the cached data is parseable
            if ! echo "$subtasks" | jq -e . >/dev/null 2>&1; then
                # Cache is corrupted, remove it and fetch fresh
                rm -f "$subtask_cache_file"
                echo "Cached subtasks corrupted, fetching fresh..." >&2
                subtasks=$(fetch_subtasks_simple "$task_ids" "$auth_header" "$USER_ID" "$max_subtask_depth")
                if [ -n "$subtasks" ]; then
                    echo "$subtasks" > "$subtask_cache_file"
                fi
            fi
        else
            # Show progress indicator
            update_spinner "Sub-scribing to subtasks (max depth: $max_subtask_depth)..."
            
            # Fetch all subtasks with simplified approach
            subtasks=$(fetch_subtasks_simple "$task_ids" "$auth_header" "$USER_ID" "$max_subtask_depth")
            
            # Cache the subtasks
            if [ -n "$subtasks" ]; then
                echo "$subtasks" > "$subtask_cache_file"
            fi
        fi
        
        # Combine initial tasks and subtasks
        local all_tasks="$initial_tasks"
        if [ -n "$subtasks" ]; then
            all_tasks=$(echo -e "$initial_tasks\n$subtasks")
            # Debug: show that subtasks are being combined
            if [ "$debug_mode" = "true" ]; then
                echo "DEBUG: Subtasks found: $(echo "$subtasks" | wc -l) lines" >&2
                echo "DEBUG: Combined tasks: $(echo "$all_tasks" | wc -l) lines" >&2
                echo "DEBUG: Task 26293712 in subtasks: $(echo "$subtasks" | grep -c "26293712")" >&2
                echo "DEBUG: Task 26293712 in all_tasks: $(echo "$all_tasks" | grep -c "26293712")" >&2
            fi
        fi
        
        # Parse combined tasks and subtasks JSON with error handling
        local tasks_data=""
        if [ -n "$all_tasks" ]; then
            # Filter valid JSON objects and combine them into an array
            local valid_json=""
            while IFS= read -r line; do
                if [ -n "$line" ] && echo "$line" | jq -e . >/dev/null 2>&1; then
                    valid_json="${valid_json}${line}"$'\n'
                    # Debug: check if this line contains task 26293712
                    if [ "$debug_mode" = "true" ] && echo "$line" | grep -q "26293712"; then
                        echo "DEBUG: Task 26293712 passed validation (valid JSON)" >&2
                    fi
                else
                    # Try to fix the invalid JSON by removing problematic characters
                    if [ -n "$line" ]; then
                        # Debug: check if this invalid line contains task 26293712
                        if [ "$debug_mode" = "true" ] && echo "$line" | grep -q "26293712"; then
                            echo "DEBUG: Task 26293712 failed JSON validation - attempting fix" >&2
                            echo "DEBUG: Problematic JSON: $(echo "$line" | head -c 200)..." >&2
                        fi
                        
                        # Remove problematic escape sequences and control characters
                        local cleaned_line=$(echo "$line" | sed 's/\\n/\\\\n/g' | sed 's/\\&/\&/g')
                        if echo "$cleaned_line" | jq -e . >/dev/null 2>&1; then
                            valid_json="${valid_json}${cleaned_line}"$'\n'
                            if [ "$debug_mode" = "true" ] && echo "$cleaned_line" | grep -q "26293712"; then
                                echo "DEBUG: Task 26293712 fixed and passed validation" >&2
                            fi
                        else
                            if [ "$debug_mode" = "true" ] && echo "$line" | grep -q "26293712"; then
                                echo "DEBUG: Task 26293712 could not be fixed - FILTERED OUT" >&2
                            fi
                        fi
                    fi
                fi
            done <<< "$all_tasks"
            
            if [ -n "$valid_json" ]; then
                # Deduplicate by task ID before sorting
                tasks_data=$(echo "$valid_json" | jq -s "map(.) | unique_by(.id) | $sort_expression")
            else
                tasks_data="[]"
            fi
        else
            tasks_data="[]"
        fi
    else
        # Parse each JSON object individually and combine into array
        local tasks_data=""
        if [ -n "$initial_tasks" ]; then
            # Filter valid JSON objects
            local valid_json=""
            while IFS= read -r line; do
                if [ -n "$line" ] && echo "$line" | jq -e . >/dev/null 2>&1; then
                    valid_json="${valid_json}${line}"$'\n'
                else
                    # Try to fix the invalid JSON
                    if [ -n "$line" ]; then
                        local cleaned_line=$(echo "$line" | sed 's/\\n/\\\\n/g' | sed 's/\\&/\&/g')
                        if echo "$cleaned_line" | jq -e . >/dev/null 2>&1; then
                            valid_json="${valid_json}${cleaned_line}"$'\n'
                        fi
                    fi
                fi
            done <<< "$initial_tasks"
            
            if [ -n "$valid_json" ]; then
                # No need to deduplicate initial tasks only, but keep consistent
                tasks_data=$(echo "$valid_json" | jq -s "map(.) | $sort_expression")
            else
                tasks_data="[]"
            fi
        else
            tasks_data="[]"
        fi
    fi
    
    # Count total tasks found
    local task_count=$(echo "$tasks_data" | jq 'length')
    
    # Terminal clearing removed - no longer clearing screen
    
    # Stop spinner and display task summary
    stop_spinner
    echo "Found $task_count task(s) assigned to you."
    echo "Tasks displayed in $order_description."
    echo
    
    # Separate actioned and non-actioned tasks
    local actioned_tasks=""
    local regular_tasks=""
    
    # First pass: separate actioned tasks from regular tasks
    while IFS= read -r task; do
        local task_id=$(echo "$task" | jq -r '.id')
        local updated_at=$(echo "$task" | jq -r '.updatedAt // ""')
        local created_at=$(echo "$task" | jq -r '.createdAt // ""')
        
        if [ -n "$task_id" ] && [ -n "$updated_at" ] && is_task_actioned "$task_id" "$updated_at"; then
            actioned_tasks="${actioned_tasks}${task}"$'\n'
        else
            regular_tasks="${regular_tasks}${task}"$'\n'
        fi
    done <<< "$(echo "$tasks_data" | jq -c '.[]')"
    
    # Display actioned tasks first as headers
    if [ -n "$actioned_tasks" ]; then
        while IFS= read -r task; do
            [ -z "$task" ] && continue
            
            local task_id=$(echo "$task" | jq -r '.id')
            local task_name=$(echo "$task" | jq -r '.name')
            local updated_at=$(echo "$task" | jq -r '.updatedAt // ""')
        local created_at=$(echo "$task" | jq -r '.createdAt // ""')
            
            # Display actioned task as a simple header with grey title and ID, and green status
            echo -e "\033[90m${task_name} #${task_id}\033[0m \033[32m✔ Actioned\033[0m"
        done <<< "$actioned_tasks"
        
        # Add spacing after actioned tasks if there are any
        echo
    fi
    
    # Format and display regular tasks (only if not in interactive mode)
    local total_tasks=$(echo "$regular_tasks" | grep -c '^{')
    local task_counter=0
    
    # Show header for clean format (always)
    printf "\n  TASKS (%d found) - Due date order\n" "$total_tasks"
    printf "\n"
    
    # Process regular tasks with progress tracking
    while IFS= read -r task; do
        [ -z "$task" ] && continue
        task_counter=$((task_counter + 1))
        local task_id=$(echo "$task" | jq -r '.id')
        local task_name=$(echo "$task" | jq -r '.name')
        local due_date=$(echo "$task" | jq -r '.dueDate // "No due date"')
        local start_date=$(echo "$task" | jq -r '.startDate // "No start date"')
        local priority=$(echo "$task" | jq -r '.priority // "Normal"')
        local description=$(echo "$task" | jq -r '.description // ""' | sed 's/<[^>]*>//g' | sed 's/|[[:space:]]*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local tag_ids=$(echo "$task" | jq -r '.tagIds // "[]"')
        local updated_at=$(echo "$task" | jq -r '.updatedAt // ""')
        local created_at=$(echo "$task" | jq -r '.createdAt // ""')
        local parent_task_id=$(echo "$task" | jq -r '.parentTaskId // 0')
        local task_level=$(echo "$task" | jq -r '.level // 0')
        local formatted_due=$(echo "$due_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$due_date")
        local formatted_start=$(echo "$start_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$start_date")
        
        # Apply filters - skip task if it doesn't match
        if ! matches_priority_filter "$priority" "$priority_filter"; then
            continue
        fi
        
        if ! matches_due_filter "$due_date" "$due_filter"; then
            continue
        fi
        
        if ! matches_start_filter "$start_date" "$start_filter"; then
            continue
        fi
        
        if ! matches_tags_filter "$tag_ids" "$tags_lookup" "$tags_filter"; then
            continue
        fi
        
        # Format tags if needed
        local formatted_tags=""
        if [ -n "$tags_filter" ]; then
            formatted_tags=$(format_tags "$tag_ids" "$tags_lookup")
        fi
        
        # Priority display with emoji
        local priority_display="$priority"
        case "$priority" in
            "high") priority_display="HIGH" ;;
            "medium") priority_display="MEDIUM" ;;
            "low") priority_display="LOW" ;;
            *) priority_display="NORMAL" ;;
        esac
        
        # Format priority with color
        local formatted_priority=$(format_priority "$priority_display")
        
        # Format due date with overdue check
        local formatted_due_with_color=$(format_due_date "$due_date" "$formatted_due")
        
        # Format task title in bold with status indicators (but not actioned status since these are regular tasks)
        local formatted_title=$(format_task_title "$task_name" "$task_id" "$task_level")
        local status_indicators=$(build_status_indicators "$task_id" "$updated_at" "$created_at" "$display_timezone")
        
        # Build task URL
        local task_url="$TEAMWORK_URL/app/tasks/$task_id"
        
        # Check for quick mode
        if [ "$quick_mode" = "true" ]; then
            # Format priority for quick mode
            local priority_short=""
            case "$priority" in
                "high") priority_short="H" ;;
                "medium") priority_short="M" ;;
                "low") priority_short="L" ;;
                *) priority_short="N" ;;
            esac
            
            # Display title with ID, priority, and due date using printf -e for color support
            if [[ "$formatted_due" == *"OVERDUE"* ]]; then
                printf "\e[90m#%s\e[0m [\e[91m%s\e[0m] %s \e[90m|\e[0m \e[91m%s\e[0m\n" "$task_id" "$priority_short" "$task_name" "$formatted_due"
            else
                # Color priority based on level
                case "$priority" in
                    "high") 
                        printf "\e[90m#%s\e[0m [\e[91m%s\e[0m] %s \e[90m|\e[0m \e[90m%s\e[0m\n" "$task_id" "$priority_short" "$task_name" "$formatted_due"
                        ;;
                    "medium") 
                        printf "\e[90m#%s\e[0m [\e[93m%s\e[0m] %s \e[90m|\e[0m \e[90m%s\e[0m\n" "$task_id" "$priority_short" "$task_name" "$formatted_due"
                        ;;
                    "low") 
                        printf "\e[90m#%s\e[0m [\e[92m%s\e[0m] %s \e[90m|\e[0m \e[90m%s\e[0m\n" "$task_id" "$priority_short" "$task_name" "$formatted_due"
                        ;;
                    *) 
                        printf "\e[90m#%s\e[0m [\e[90m%s\e[0m] %s \e[90m|\e[0m \e[90m%s\e[0m\n" "$task_id" "$priority_short" "$task_name" "$formatted_due"
                        ;;
                esac
            fi
            continue
        fi
        
        # Always use clean format for all task displays
        if true; then
            # Use clean formatting for all tasks
            local comments_data=""
            if [ -n "$comments_mode" ]; then
                comments_data=$(fetch_task_comments_for_display "$task_id" "$comments_mode")
            fi
            
            # Get AI summary
            local ai_summary=""
            if [ -n "$summary_mode" ]; then
                start_spinner "Generating AI summary $task_counter of $total_tasks..."
                local task_with_comments=$(get_task_with_comments "$task_id")
                if [ -n "$task_with_comments" ]; then
                    ai_summary=$(generate_long_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                fi
                stop_spinner
            fi
            
            # Display in clean format
            format_clean_task_display "$task_name" "$task_id" "$priority" "$formatted_due" "$description" "$ai_summary" "$comments_data" "$comments_mode" "$task_url"
            continue
        fi
    done <<< "$regular_tasks"
    
    # Stop spinner if still running
    stop_spinner
}


# Function to mark task as complete via Teamwork API
complete_task_api() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    echo "Marking task $task_id as complete..."
    
    local auth_header=$(get_auth_header)
    local response=$(curl -s -X PUT -H "$auth_header" \
        "$TEAMWORK_URL/tasks/$task_id/complete.json" 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        local status=$(echo "$response" | jq -r '.STATUS // ""' 2>/dev/null)
        if [ "$status" = "OK" ]; then
            echo "✓ Task $task_id marked as complete"
            # Clear related cache to force refresh
            clear_task_cache "$task_id"
            return 0
        else
            echo "Error: Failed to mark task complete - $response"
            return 1
        fi
    else
        echo "Error: API call failed"
        return 1
    fi
}

# Function to add a comment to a task
add_task_comment() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        return 1
    fi
    
    # Validate task ID is numeric
    if ! [[ "$task_id" =~ ^[0-9]+$ ]]; then
        echo "Error: Task ID must be numeric"
        return 1
    fi
    
    echo "Add a comment to task $task_id:"
    echo "(Press Ctrl+C to cancel, or enter empty line to finish)"
    echo
    
    # Read comment text - allow multi-line
    local comment_text=""
    local line
    echo "Comment: "
    while IFS= read -r line; do
        if [ -z "$line" ]; then
            break
        fi
        comment_text="${comment_text}${line}\n"
    done
    
    if [ -z "$comment_text" ]; then
        echo "No comment entered. Skipping..."
        return 0
    fi
    
    echo "Adding comment..."
    
    local auth_header=$(get_auth_header)
    local json_payload=$(jq -n --arg body "$comment_text" '{
        "comment": {
            "body": $body,
            "notify": "",
            "isprivate": false
        }
    }')
    
    local response=$(curl -s -X POST -H "$auth_header" \
        -H "Content-Type: application/json" \
        -d "$json_payload" \
        "$TEAMWORK_URL/tasks/$task_id/comments.json" 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        local status=$(echo "$response" | jq -r '.STATUS // ""' 2>/dev/null)
        if [ "$status" = "OK" ]; then
            echo "✓ Comment added to task $task_id"
            # Clear related cache to force refresh
            clear_task_cache "$task_id"
            return 0
        else
            echo "Error: Failed to add comment - $response"
            return 1
        fi
    else
        echo "Error: API call failed"
        return 1
    fi
}

# Function to show comments for a task
show_task_comments() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        echo "Error: Task ID is required"
        return 1
    fi
    
    echo "Loading comments for task $task_id..."
    
    local auth_header=$(get_auth_header)
    local comments_response=$(curl -s -H "$auth_header" \
        "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/comments.json?pageSize=20&orderMode=desc" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$comments_response" ]; then
        echo "Error: Failed to fetch comments"
        return 1
    fi
    
    local comments_count=$(echo "$comments_response" | jq '.comments | length' 2>/dev/null)
    
    if [ "$comments_count" = "0" ] || [ "$comments_count" = "null" ]; then
        echo "No comments found for this task."
        return 0
    fi
    
    echo
    echo "=== Comments ($comments_count) ==="
    echo
    
    # Display comments using existing display function
    local comments_data=$(fetch_task_comments_for_display "$task_id" "20")
    if [ -n "$comments_data" ]; then
        echo "$comments_data"
    else
        echo "No comments to display."
    fi
}

# Function to find task by title
find_task_by_title() {
    local search_title="$1"
    local project_id=$(select_project)
    
    if [ $? -ne 0 ] || [ -z "$project_id" ]; then
        echo "Error: No project selected. Please run 'tw' to select a project first." >&2
        return 1
    fi
    
    # Try to load from cache first
    local cache_key="tasks_${project_id}_${USER_ID}_with_tasklists"
    local cache_file=$(get_cache_file "$cache_key")
    
    if ! is_cache_valid "$cache_file"; then
        echo "Error: No cached task data available. Please run 'tw tasks' first." >&2
        return 1
    fi
    
    local response=$(cat "$cache_file")
    
    # Search for task by title (case insensitive partial match)
    local search_lower=$(echo "$search_title" | tr '[:upper:]' '[:lower:]')
    local found_tasks=$(echo "$response" | jq -r --arg user_id "$USER_ID" --arg search "$search_lower" '
        .tasks[]
        | select(.assigneeUserIds[]? == ($user_id | tonumber))
        | select(.name | ascii_downcase | contains($search))
        | {id: .id, name: .name}
    ' | jq -s '.')
    
    local task_count=$(echo "$found_tasks" | jq 'length')
    
    if [ "$task_count" -eq 0 ]; then
        echo "Error: No tasks found matching '$search_title'" >&2
        return 1
    elif [ "$task_count" -eq 1 ]; then
        echo "$found_tasks" | jq -r '.[0].id'
        return 0
    else
        echo "Error: Multiple tasks found matching '$search_title':" >&2
        echo "$found_tasks" | jq -r '.[] | "  ID: \(.id) - \(.name)"' >&2
        echo "Please be more specific or use the task ID directly." >&2
        return 1
    fi
}

# Function to open task in browser
open_task() {
    local input="$1"
    shift # Remove first argument, rest will be treated as part of title if needed
    
    # Check for flags in remaining arguments and build complete title
    local remaining_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --*)
                # Skip flags for open command
                shift
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    if [ -z "$input" ]; then
        echo "Error: Task ID or title is required"
        echo "Usage: tw open {ID|Title}"
        exit 1
    fi
    
    local task_id=""
    
    # Check if input is numeric (task ID)
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        task_id="$input"
    else
        # Combine input with remaining args as the task title search
        local search_title="$input"
        if [ ${#remaining_args[@]} -gt 0 ]; then
            search_title="$input ${remaining_args[*]}"
        fi
        
        echo "Searching for task: '$search_title'..."
        task_id=$(find_task_by_title "$search_title")
        
        if [ $? -ne 0 ] || [ -z "$task_id" ]; then
            exit 1
        fi
        
        echo "Found task ID: $task_id"
    fi
    
    # Build task URL
    local task_url="$TEAMWORK_URL/app/tasks/$task_id"
    echo "Opening task in browser: $task_url"
    
    # Open the URL in the default browser
    if command -v open &> /dev/null; then
        # macOS
        open "$task_url"
    elif command -v xdg-open &> /dev/null; then
        # Linux
        xdg-open "$task_url"
    elif command -v start &> /dev/null; then
        # Windows
        start "$task_url"
    else
        echo "Could not automatically open browser. Please manually open:"
        echo "$task_url"
    fi
}

# Function to get activity/timeline for the user
get_activity() {
    echo "Activity feature not yet implemented."
}

# Function to show help in clean format
show_help() {
    printf "\033[1mTEAMWORK CLI\033[0m - Modern command-line interface for Teamwork.com\n\n"
    
    printf "\033[1mUSAGE\033[0m\n"
    printf "   tw                         Select project interactively\n"
    printf "   tw tasks [options]         List tasks assigned to you\n" 
    printf "   tw task {ID|Title}         View single task details\n"
    printf "   tw open {ID|Title}         Open task in browser\n"
    printf "   tw action {ID}             Mark task as actioned\n"
    printf "   tw unaction {ID}           Remove actioned status\n"
    printf "   tw refresh                 Clear cached data\n"
    printf "   tw flags                   Show this help message\n\n"
    
    printf "\033[1mTASK LIST OPTIONS\033[0m (for 'tw tasks')\n"
    printf "   --priority=VALUE           Filter by priority (high, medium, low, normal)\n"
    printf "   --due=VALUE                Filter by due date (today, overdue, YYYY-MM-DD)\n"
    printf "   --start=VALUE              Filter by start date (today, YYYY-MM-DD)\n"
    printf "   --tags=VALUE               Filter by tag name (case insensitive)\n"
    printf "   --order=VALUE              Sort by: priority, lastupdated, duedate, start\n"
    printf "   --quick                    Quick view: titles with IDs, priority, and due dates\n"
    printf "   --no-summary               Disable AI summaries\n"
    printf "   --comments                 Show latest 3 comments per task (default)\n"
    printf "   --comments=N               Show latest N comments per task\n"
    printf "   --no-comments              Hide comments\n"
    printf "   --timezone=VALUE           Set display timezone (UTC, Australia/Melbourne)\n\n"
    
    printf "\033[1mSINGLE TASK OPTIONS\033[0m (for 'tw task')\n"
    printf "   --no-summary               Disable AI summary\n"
    printf "   --comments                 Show all comments (default)\n"
    printf "   --comments=N               Show latest N comments\n"
    printf "   --no-comments              Hide comments\n"
    printf "   --output=html              Open task as HTML in browser\n"
    printf "   --timezone=VALUE           Set display timezone\n\n"
    
    printf "\033[1mFEATURES\033[0m\n"
    printf "   • Clean, modern terminal interface\n"
    printf "   • Smart caching with auto-refresh\n"
    printf "   • AI-powered task summaries (requires Claude CLI)\n"
    printf "   • Full-text task search by title or ID\n"
    printf "   • Project scoping with \"ALL PROJECTS\" option\n"
    printf "   • Task status tracking with visual indicators\n\n"
    
    printf "\033[1mCONFIGURATION\033[0m\n"
    printf "   Environment file: ~/.tw.env or ./.env\n"
    printf "   Required: TEAMWORK_URL, API_KEY, PASSWORD, USER_ID\n"
    printf "   Optional: CLAUDE_MODEL (default: claude-3-5-sonnet-20241022)\n\n"
    
    printf "\033[1mEXAMPLES\033[0m\n"
    printf "   tw tasks                                 # Rich view with AI summaries and comments\n"
    printf "   tw task 123456                           # Single task with AI summary and comments\n"  
    printf "   tw tasks --priority=high --due=overdue   # Urgent tasks only\n"
    printf "   tw tasks --no-comments                   # Hide comments\n"
    printf "   tw action 123456                         # Mark as actioned\n"
    printf "\n"
}

# Function to generate HTML for task display
generate_task_html() {
    local task_data="$1"
    local task_id="$2" 
    local summary_mode="$3"
    local comments_mode="$4"
    local comments_limit="$5"
    local debug_mode="$6"
    
    # Extract task details
    local task_name=$(echo "$task_data" | jq -r '.name // "Unknown Task"')
    local due_date=$(echo "$task_data" | jq -r '.dueDate // "No due date"')
    local start_date=$(echo "$task_data" | jq -r '.startDate // "No start date"')
    local priority=$(echo "$task_data" | jq -r '.priority // "Normal"')
    local description=$(echo "$task_data" | jq -r '.description // ""' | sed 's/<[^>]*>//g' | sed 's/|[[:space:]]*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    local tag_ids=$(echo "$task_data" | jq -r '.tagIds // "[]"')
    local updated_at=$(echo "$task_data" | jq -r '.updatedAt // ""')
    local created_at=$(echo "$task_data" | jq -r '.createdAt // ""')
    local project_id=$(echo "$task_data" | jq -r '.projectId // ""')
    
    # Format dates
    local formatted_due=$(echo "$due_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$due_date")
    local formatted_start=$(echo "$start_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$start_date")
    
    # Format tags if present
    local formatted_tags=""
    if [ "$tag_ids" != "[]" ] && [ "$tag_ids" != "null" ]; then
        local tags_lookup=$(fetch_tags "$project_id")
        formatted_tags=$(format_tags "$tag_ids" "$tags_lookup")
    fi
    
    # Priority styling
    local priority_class=""
    local priority_display="NORMAL"
    case "$priority" in
        "high") priority_display="HIGH"; priority_class="high" ;;
        "medium") priority_display="MEDIUM"; priority_class="medium" ;;
        "low") priority_display="LOW"; priority_class="low" ;;
        *) priority_display="NORMAL"; priority_class="normal" ;;
    esac
    
    # Check if due date is overdue
    local due_class=""
    if [ "$due_date" != "No due date" ] && [ "$due_date" != "null" ]; then
        local current_date=$(date +%Y-%m-%d)
        local due_date_only=$(echo "$due_date" | sed 's/T.*//')
        if [[ "$due_date_only" < "$current_date" ]]; then
            due_class="overdue"
        fi
    fi
    
    # Build task URL
    local task_url="$TEAMWORK_URL/app/tasks/$task_id"
    
    # Start HTML generation
    cat << EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task #$task_id - $task_name</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            line-height: 1.6; 
            margin: 0; 
            padding: 20px; 
            background-color: #f5f5f5; 
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            overflow: hidden;
        }
        .header { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            padding: 20px; 
        }
        .task-title { 
            font-size: 1.8em; 
            font-weight: bold; 
            margin: 0; 
        }
        .task-id { 
            opacity: 0.8; 
            font-size: 0.9em; 
        }
        .content { 
            padding: 20px; 
        }
        .field { 
            margin-bottom: 15px; 
        }
        .field-label { 
            font-weight: bold; 
            color: #333; 
            display: inline-block; 
            width: 100px; 
        }
        .priority { 
            padding: 4px 8px; 
            border-radius: 4px; 
            font-weight: bold; 
            font-size: 0.8em; 
        }
        .priority.high { 
            background-color: #ffebee; 
            color: #c62828; 
            border: 1px solid #ef5350; 
        }
        .priority.medium { 
            background-color: #fff3e0; 
            color: #ef6c00; 
            border: 1px solid #ff9800; 
        }
        .priority.low { 
            background-color: #e8f5e8; 
            color: #2e7d32; 
            border: 1px solid #4caf50; 
        }
        .priority.normal { 
            background-color: #f5f5f5; 
            color: #666; 
            border: 1px solid #ccc; 
        }
        .overdue { 
            color: #c62828; 
            font-weight: bold; 
        }
        .description { 
            background-color: #f9f9f9; 
            border-left: 4px solid #667eea; 
            padding: 15px; 
            margin: 15px 0; 
            white-space: pre-wrap; 
        }
        .tags { 
            display: flex; 
            gap: 5px; 
            flex-wrap: wrap; 
            margin-top: 5px; 
        }
        .tag { 
            background-color: #e3f2fd; 
            color: #1976d2; 
            padding: 2px 8px; 
            border-radius: 12px; 
            font-size: 0.8em; 
        }
        .url-link { 
            color: #1976d2; 
            text-decoration: none; 
            word-break: break-all; 
        }
        .url-link:hover { 
            text-decoration: underline; 
        }
        .ai-summary { 
            background-color: #f3e5f5; 
            border-left: 4px solid #9c27b0; 
            padding: 15px; 
            margin: 15px 0; 
        }
        .ai-summary-title { 
            font-weight: bold; 
            color: #7b1fa2; 
            margin-bottom: 15px; 
            font-size: 1.1em;
        }
        .summary-section, .next-steps-section {
            margin-bottom: 15px;
        }
        .summary-section h4, .next-steps-section h4 {
            color: #7b1fa2;
            margin: 0 0 10px 0;
            font-size: 1em;
            font-weight: 600;
        }
        .summary-section p {
            margin: 5px 0;
            line-height: 1.5;
        }
        .next-steps-section ul {
            margin: 0;
            padding-left: 20px;
        }
        .next-steps-section li {
            margin-bottom: 5px;
            line-height: 1.5;
        }
        .comments-section { 
            margin-top: 20px; 
        }
        .comments-title { 
            font-size: 1.2em; 
            font-weight: bold; 
            margin-bottom: 15px; 
            color: #333; 
        }
        .comment { 
            border: 1px solid #e0e0e0; 
            border-radius: 8px; 
            margin-bottom: 10px; 
            overflow: hidden; 
        }
        .comment-header { 
            background-color: #f8f9fa; 
            padding: 10px 15px; 
            font-size: 0.9em; 
            color: #666; 
        }
        .comment-author { 
            font-weight: bold; 
            color: #333; 
        }
        .comment-body { 
            padding: 15px; 
            white-space: pre-wrap; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="task-title">$task_name</h1>
            <div class="task-id">#$task_id</div>
        </div>
        <div class="content">
            <div class="field">
                <span class="field-label">Priority:</span>
                <span class="priority $priority_class">$priority_display</span>
            </div>
            
            <div class="field">
                <span class="field-label">Due:</span>
                <span class="$([ "$due_class" = "overdue" ] && echo "overdue")">$formatted_due</span>
            </div>
EOF

    # Add start date if set
    if [ "$start_date" != "No start date" ] && [ "$start_date" != "null" ]; then
        echo "            <div class=\"field\">"
        echo "                <span class=\"field-label\">Start:</span>"
        echo "                <span>$formatted_start</span>"
        echo "            </div>"
    fi
    
    # Add description if it exists
    if [ -n "$description" ] && [ "$description" != "null" ] && [ "$description" != "" ]; then
        echo "            <div class=\"field\">"
        echo "                <span class=\"field-label\">Description:</span>"
        echo "                <div class=\"description\">$(echo "$description" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')</div>"
        echo "            </div>"
    fi
    
    # Add URL
    echo "            <div class=\"field\">"
    echo "                <span class=\"field-label\">URL:</span>"
    echo "                <a href=\"$task_url\" class=\"url-link\" target=\"_blank\">$task_url</a>"
    echo "            </div>"
    
    # Add tags if they exist
    if [ -n "$formatted_tags" ]; then
        echo "            <div class=\"field\">"
        echo "                <span class=\"field-label\">Tags:</span>"
        echo "                <div class=\"tags\">"
        # Convert formatted_tags to individual tag spans
        echo "$formatted_tags" | tr ',' '\n' | while read -r tag; do
            tag=$(echo "$tag" | sed 's/^ *//; s/ *$//')  # Trim whitespace
            if [ -n "$tag" ]; then
                echo "                    <span class=\"tag\">$tag</span>"
            fi
        done
        echo "                </div>"
        echo "            </div>"
    fi
    
    # Add AI summary if requested
    if [ -n "$summary_mode" ]; then
        local task_with_comments=$(get_task_with_comments "$task_id")
        if [ -n "$task_with_comments" ]; then
            case "$summary_mode" in
                "short"|"long")
                    local ai_summary=""
                    if [ "$summary_mode" = "short" ]; then
                        ai_summary=$(generate_short_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode" 2>/dev/null)
                    else
                        ai_summary=$(generate_long_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode" 2>/dev/null)
                    fi
                    
                    if [ -n "$ai_summary" ]; then
                        echo "            <div class=\"ai-summary\">"
                        echo "                <div class=\"ai-summary-title\">🤖 AI Analysis</div>"
                        
                        # Parse the AI summary to handle structured sections
                        # First, split the summary into sections
                        local summary_part=""
                        local next_steps_part=""
                        local in_next_steps=false
                        
                        while IFS= read -r line; do
                            if [[ "$line" =~ ^AI\ Summary: ]]; then
                                # Extract content after "AI Summary: "
                                local content="${line#AI Summary: }"
                                if [ -n "$content" ]; then
                                    summary_part="$summary_part$content\n"
                                fi
                                in_next_steps=false
                            elif [[ "$line" =~ ^Next\ Steps: ]]; then
                                in_next_steps=true
                                # Extract content after "Next Steps: " if any
                                local content="${line#Next Steps: }"
                                if [ -n "$content" ] && [ "$content" != "$line" ]; then
                                    next_steps_part="$next_steps_part$content\n"
                                fi
                            elif [ -n "$line" ]; then
                                # Handle regular content lines
                                if [ "$in_next_steps" = true ]; then
                                    next_steps_part="$next_steps_part$line\n"
                                else
                                    summary_part="$summary_part$line\n"
                                fi
                            fi
                        done <<< "$ai_summary"
                        
                        # Output the summary section if it exists
                        if [ -n "$summary_part" ]; then
                            echo "                <div class=\"summary-section\">"
                            echo "                    <h4>Summary</h4>"
                            echo -e "$summary_part" | while IFS= read -r line; do
                                if [ -n "$line" ]; then
                                    echo "                    <p>$(echo "$line" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')</p>"
                                fi
                            done
                            echo "                </div>"
                        fi
                        
                        # Output the next steps section if it exists
                        if [ -n "$next_steps_part" ]; then
                            echo "                <div class=\"next-steps-section\">"
                            echo "                    <h4>Next Steps</h4>"
                            echo "                    <ul>"
                            echo -e "$next_steps_part" | while IFS= read -r line; do
                                if [ -n "$line" ]; then
                                    # Remove "- " prefix if present
                                    if [[ "$line" =~ ^-\  ]]; then
                                        local item="${line#- }"
                                        echo "                        <li>$(echo "$item" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')</li>"
                                    else
                                        echo "                        <li>$(echo "$line" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')</li>"
                                    fi
                                fi
                            done
                            echo "                    </ul>"
                            echo "                </div>"
                        fi
                        
                        echo "            </div>"
                    fi
                    ;;
            esac
        fi
    fi
    
    # Add comments if requested
    if [ -n "$comments_mode" ]; then
        generate_comments_html "$task_id" "$comments_limit"
    fi
    
    cat << EOF
        </div>
    </div>
</body>
</html>
EOF
}

# Function to generate HTML for comments
generate_comments_html() {
    local task_id="$1"
    local comments_limit="$2"
    
    # Fetch comments using the same logic as format_task_comments
    local auth_header=$(get_auth_header)
    local page_size="50"
    
    if [ "$comments_limit" != "all" ] && [[ "$comments_limit" =~ ^[0-9]+$ ]]; then
        local requested_limit="$comments_limit"
        if [ "$requested_limit" -lt 50 ]; then
            page_size="50"
        else
            page_size="$requested_limit"
        fi
    fi
    
    local comments_response=$(curl -s -H "$auth_header" \
        "$TEAMWORK_URL/projects/api/v3/tasks/$task_id/comments.json?pageSize=$page_size&orderMode=desc" 2>/dev/null | sed 's/\\r//g; s/\\n/ /g')
    
    if [ $? -ne 0 ] || [ -z "$comments_response" ]; then
        return 1
    fi
    
    local error=$(echo "$comments_response" | jq -r '.error // empty')
    if [ -n "$error" ]; then
        return 1
    fi
    
    local comments_data=$(echo "$comments_response" | jq -r '.comments // []')
    local total_comments=$(echo "$comments_data" | jq 'length')
    
    if [ "$total_comments" -eq 0 ]; then
        return 0
    fi
    
    # Apply limit if specified
    local display_comments=""
    if [ "$comments_limit" = "all" ]; then
        display_comments="$comments_data"
    elif [[ "$comments_limit" =~ ^[0-9]+$ ]]; then
        local limit_num="$comments_limit"
        if [ "$limit_num" -ge "$total_comments" ]; then
            display_comments="$comments_data"
        else
            display_comments=$(echo "$comments_data" | jq ".[0:$limit_num]")
        fi
    else
        display_comments="$comments_data"
    fi
    
    # Create user cache for comments
    local user_cache_file=$(mktemp)
    local user_ids=$(echo "$display_comments" | jq -r '.[].postedByUserId // empty' | sort -u)
    
    if [ -n "$user_ids" ]; then
        echo "$user_ids" | while read -r user_id; do
            if [ -n "$user_id" ] && [ "$user_id" != "null" ]; then
                local user_response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/people/$user_id.json" 2>/dev/null)
                if [ $? -eq 0 ] && [ -n "$user_response" ]; then
                    local first_name=$(echo "$user_response" | jq -r '.person.firstName // ""')
                    local last_name=$(echo "$user_response" | jq -r '.person.lastName // ""')
                    local full_name=""
                    
                    if [ -n "$first_name" ] && [ -n "$last_name" ]; then
                        full_name="$first_name $last_name"
                    elif [ -n "$first_name" ]; then
                        full_name="$first_name"
                    elif [ -n "$last_name" ]; then
                        full_name="$last_name"
                    else
                        full_name="User $user_id"
                    fi
                    
                    echo "$user_id|$full_name" >> "$user_cache_file"
                fi
            fi
        done
    fi
    
    echo "            <div class=\"comments-section\">"
    if [ "$comments_limit" = "all" ]; then
        echo "                <div class=\"comments-title\">Comments ($total_comments total)</div>"
    elif [[ "$comments_limit" =~ ^[0-9]+$ ]]; then
        local limit_num="$comments_limit"
        if [ "$limit_num" -ge "$total_comments" ]; then
            echo "                <div class=\"comments-title\">Comments (showing all $total_comments)</div>"
        else
            echo "                <div class=\"comments-title\">Comments (showing latest $limit_num of $total_comments)</div>"
        fi
    else
        echo "                <div class=\"comments-title\">Comments</div>"
    fi
    
    # Display each comment
    echo "$display_comments" | jq -r '.[] | 
        (.postedDateTime // .createdDate // .dateCreated // "Unknown date") + "|" + 
        ((.postedByUserId // "unknown") | tostring) + "|" + 
        (.body // "No content")' | while IFS='|' read -r date_part user_id_part content_part; do
        
        # Format date
        local formatted_date="$date_part"
        if [[ "$date_part" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2} ]]; then
            if [[ "$date_part" =~ Z$ ]]; then
                formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$date_part" "+%b %d, %Y at %I:%M %p" 2>/dev/null)
            elif [[ "$date_part" =~ \+[0-9]{2}:[0-9]{2}$ ]]; then
                formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "${date_part//:}" "+%b %d, %Y at %I:%M %p" 2>/dev/null)
            else
                formatted_date=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$date_part" "+%b %d, %Y at %I:%M %p" 2>/dev/null)
            fi
            
            if [ -z "$formatted_date" ]; then
                formatted_date="$date_part"
            fi
        fi
        
        # Get author name
        local author_name="Unknown User"
        if [ "$user_id_part" != "unknown" ] && [ -f "$user_cache_file" ]; then
            author_name=$(grep "^$user_id_part|" "$user_cache_file" | cut -d'|' -f2)
            if [ -z "$author_name" ]; then
                author_name="Unknown User"
            fi
        fi
        
        # Escape HTML in content
        local escaped_content=$(echo "$content_part" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
        
        echo "                <div class=\"comment\">"
        echo "                    <div class=\"comment-header\">"
        echo "                        <span class=\"comment-author\">$author_name</span> • $formatted_date"
        echo "                    </div>"
        echo "                    <div class=\"comment-body\">$escaped_content</div>"
        echo "                </div>"
    done
    
    echo "            </div>"
    
    # Clean up temp file
    rm -f "$user_cache_file"
}

# Function to show single task details
show_single_task() {
    local input="$1"
    shift # Remove first argument, rest will be treated as options or part of title
    
    # Parse flags
    local summary_mode="long"
    local debug_mode="false"
    local display_timezone="UTC"  # Default to UTC
    local comments_mode="true"  # Show comments by default
    local comments_limit="all"
    local output_format=""
    local remaining_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-summary)
                summary_mode=""
                shift
                ;;
            --comments=*)
                comments_mode="true"
                comments_limit="${1#*=}"
                shift
                ;;
            --comments)
                comments_mode="true"
                comments_limit="all"
                shift
                ;;
            --no-comments)
                comments_mode=""
                comments_limit=""
                shift
                ;;
            --debug)
                debug_mode="true"
                shift
                ;;
            --timezone=*)
                display_timezone="${1#*=}"
                shift
                ;;
            --output=*)
                output_format="${1#*=}"
                shift
                ;;
            --help)
                echo "Use 'tw flags' to see available commands and options."
                return 0
                ;;
            --*)
                echo "Unknown option: $1"
                echo "Use 'tw task --help' for usage information."
                return 1
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Handle help flag as first argument
    if [ "$input" = "--help" ]; then
        echo "Use 'tw flags' to see available commands and options."
        return 0
    fi
    
    if [ -z "$input" ]; then
        echo "Error: Task ID or title is required"
        echo "Usage: tw task {ID|Title} [options]"
        return 1
    fi
    
    local task_id=""
    
    # Check if input is numeric (task ID)
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        task_id="$input"
    else
        # Combine input with remaining args as the task title search
        local search_title="$input"
        if [ ${#remaining_args[@]} -gt 0 ]; then
            search_title="$input ${remaining_args[*]}"
        fi
        
        echo "Searching for task: '$search_title'..."
        task_id=$(find_task_by_title "$search_title")
        
        if [ $? -ne 0 ] || [ -z "$task_id" ]; then
            return 1
        fi
    fi
    
    # Fetch task details from cache or API
    local project_id=$(select_project)
    if [ $? -ne 0 ] || [ -z "$project_id" ]; then
        echo "Error: No project selected. Please run 'tw' to select a project first."
        return 1
    fi
    
    # Try to get task from cache
    local cache_key="tasks_${project_id}_${USER_ID}_with_tasklists"
    local cache_file=$(get_cache_file "$cache_key")
    local task_data=""
    
    if is_cache_valid "$cache_file"; then
        local response=$(cat "$cache_file")
        task_data=$(echo "$response" | jq -r --arg task_id "$task_id" '.tasks[] | select(.id == ($task_id | tonumber))')
    fi
    
    # If not found in cache or cache invalid, fetch directly
    if [ -z "$task_data" ] || [ "$task_data" = "null" ]; then
        local auth_header=$(get_auth_header)
        local response=$(curl -s -H "$auth_header" "$TEAMWORK_URL/projects/api/v3/tasks/$task_id.json")
        
        if [ $? -ne 0 ]; then
            echo "Error: Failed to fetch task from Teamwork API"
            return 1
        fi
        
        local error=$(echo "$response" | jq -r '.error // empty')
        if [ -n "$error" ]; then
            echo "API Error: $error"
            return 1
        fi
        
        task_data=$(echo "$response" | jq -r '.task')
    fi
    
    # Extract task details
    local task_name=$(echo "$task_data" | jq -r '.name // "Unknown Task"')
    local due_date=$(echo "$task_data" | jq -r '.dueDate // "No due date"')
    local start_date=$(echo "$task_data" | jq -r '.startDate // "No start date"')
    local priority=$(echo "$task_data" | jq -r '.priority // "Normal"')
    local description=$(echo "$task_data" | jq -r '.description // ""' | sed 's/<[^>]*>//g' | sed 's/|[[:space:]]*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    local tag_ids=$(echo "$task_data" | jq -r '.tagIds // "[]"')
    local updated_at=$(echo "$task_data" | jq -r '.updatedAt // ""')
    local created_at=$(echo "$task_data" | jq -r '.createdAt // ""')
    
    # Format dates
    local formatted_due=$(echo "$due_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$due_date")
    local formatted_start=$(echo "$start_date" | sed 's/T.*//' | xargs -I {} date -j -f "%Y-%m-%d" {} "+%A %-d %B, %Y" 2>/dev/null || echo "$start_date")
    
    # Format tags if present
    local formatted_tags=""
    if [ "$tag_ids" != "[]" ] && [ "$tag_ids" != "null" ]; then
        local tags_lookup=$(fetch_tags "$project_id")
        formatted_tags=$(format_tags "$tag_ids" "$tags_lookup")
    fi
    
    # Priority display
    local priority_display="NORMAL"
    case "$priority" in
        "high") priority_display="HIGH" ;;
        "medium") priority_display="MEDIUM" ;;
        "low") priority_display="LOW" ;;
        *) priority_display="NORMAL" ;;
    esac
    
    # Format priority with color
    local formatted_priority=$(format_priority "$priority_display")
    
    # Format due date with overdue check
    local formatted_due_with_color=$(format_due_date "$due_date" "$formatted_due")
    
    # Format task title in bold with status indicators
    local formatted_title=$(format_task_title "$task_name" "$task_id")
    local status_indicators=$(build_status_indicators "$task_id" "$updated_at" "$created_at")
    
    # Build task URL
    local task_url="$TEAMWORK_URL/app/tasks/$task_id"
    
    # Check if HTML output is requested
    if [ "$output_format" = "html" ]; then
        # Generate HTML content and save to temporary file with proper extension
        local html_file="/tmp/teamwork_task_${task_id}.html"
        
        # Generate HTML using the separate function
        generate_task_html "$task_data" "$task_id" "$summary_mode" "$comments_mode" "$comments_limit" "$debug_mode" > "$html_file"
        
        # Open in browser
        echo "Opening task #$task_id in browser..."
        if command -v open >/dev/null 2>&1; then
            # macOS - try to open with default browser
            open "$html_file" 2>/dev/null || {
                echo "HTML file created: $html_file"
                echo "Please open this file manually in your browser."
            }
        elif command -v xdg-open >/dev/null 2>&1; then
            # Linux
            xdg-open "$html_file" 2>/dev/null || {
                echo "HTML file created: $html_file"
                echo "Please open this file manually in your browser."
            }
        elif command -v start >/dev/null 2>&1; then
            # Windows
            start "$html_file" 2>/dev/null || {
                echo "HTML file created: $html_file"
                echo "Please open this file manually in your browser."
            }
        else
            echo "HTML file created: $html_file"
            echo "Please open this file manually in your browser."
        fi
        
        return 0
    fi
    
    # Display status indicators above the task table if they exist
    if [ -n "$status_indicators" ]; then
        echo -e "$status_indicators"
    fi
    
    # Get AI summary if requested
    local ai_summary=""
    if [ -n "$summary_mode" ]; then
        local task_with_comments=$(get_task_with_comments "$task_id")
        if [ -n "$task_with_comments" ]; then
            case "$summary_mode" in
                "short")
                    start_spinner "Generating AI summary..."
                    ai_summary=$(generate_short_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                    stop_spinner
                    ;;
                "long")
                    start_spinner "Generating AI summary..."
                    ai_summary=$(generate_long_summary "$task_with_comments" "$task_id" "$updated_at" "$debug_mode")
                    stop_spinner
                    ;;
            esac
        fi
    fi
    
    # Get comments if requested  
    local comments_data=""
    if [ -n "$comments_mode" ]; then
        if [ "$comments_limit" = "all" ]; then
            comments_data=$(fetch_task_comments_for_display "$task_id" "50")
        else
            comments_data=$(fetch_task_comments_for_display "$task_id" "$comments_limit")
        fi
    fi
    
    # Display task in clean format
    format_clean_single_task_display "$task_name" "$task_id" "$priority" "$formatted_due" "$formatted_start" "$description" "$task_url" "$formatted_tags" "$ai_summary" "$comments_data" "$comments_mode"
    echo
}


# Main command dispatcher
case "${1:-}" in
    "tasks")
        get_tasks "$@"
        ;;
    "task")
        if [ -z "$2" ]; then
            echo "Error: Task ID or title is required"
            echo "Usage: tw task {ID|Title} [options]"
            exit 1
        fi
        shift # Remove 'task'
        show_single_task "$@"
        ;;
    "open")
        if [ -z "$2" ]; then
            echo "Error: Task ID or title is required"
            echo "Usage: tw open {ID|Title}"
            exit 1
        fi
        shift # Remove 'open'
        open_task "$@"
        ;;
    "activity")
        get_activity
        ;;
    "action")
        if [ -z "$2" ]; then
            echo "Error: Task ID is required"
            echo "Usage: tw action {task_id}"
            exit 1
        fi
        shift # Remove 'action'
        mark_task_actioned "$1"
        ;;
    "unaction")
        if [ "$2" = "--all" ]; then
            shift # Remove 'unaction'
            shift # Remove '--all'
            unmark_all_tasks_actioned
        elif [ -z "$2" ]; then
            echo "Error: Task ID is required"
            echo "Usage: tw unaction {task_id} or tw unaction --all"
            exit 1
        else
            shift # Remove 'unaction'
            unmark_task_actioned "$1"
        fi
        ;;
    "refresh")
        if [ -n "$2" ]; then
            # Single task cache refresh
            shift # Remove 'refresh'
            clear_task_cache "$1"
        else
            # Clear all cache
            clear_cache
        fi
        ;;
    "flags"|"help"|"--help")
        show_help
        ;;
    "")
        # No arguments - run project wizard
        project_wizard
        ;;
    *)
        echo "Unknown command: $1"
        echo "Use 'tw flags' to see available commands."
        exit 1
        ;;
esac